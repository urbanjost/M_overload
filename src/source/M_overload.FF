$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#ifdef __NVCOMPILER
#undef HAS_REAL128
#else
#define HAS_REAL128
#endif
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file M_overload.3m_overload.man
NAME
   M_overload(3fm) - [M_overload::INTRO] overloads of standard operators and intrinsic procedures
   (LICENSE:PD)
SYNOPSIS
 overloads on operators

   use M_overload, only : operator(==), operator(/=)
   ! use == like .eqv.; ie. logical==logical
   ! use /= like .neqv.; ie. logical/=logical

   use M_overload, only : operator(//)
   ! convert intrinsics to strings and contatenate

 overloads on INTRINSICS to take strings, logicals, and metamorphic numeric intrinsic values

   use M_overload, only : int, real, dble
   ! int('string')   int(logical)   int(class(*))
   ! real('string')  real(logical)  real(class(*))
   ! dble('string')  dble(logical)  dble(class(*))

   use M_overload, only : sign
   ! When sign(3f) is given a single value, call sign(1,value); ie.  sign(value)
   use M_overload, only : merge
   ! Allow strings of different length in MERGE

 other operators

   .fmt.    ! convert an intrinsic value to a CHARACTER variable
   N.to.M   ! equivalent of [(integer :: i,i=N,M)], generates a range of
            ! adjacent whole numbers

 Related functions

   ! logical functions that return integer values 
   use M_overload, only : oz, zo, lt, le, eq, ne, gt, ge

$! Allow unallocated allocatable variables or allocated variables to be reallocated for strings
$! Note _ in name. Not an actual overload.
$!
$!  get_command(command,length,status,realloc=.true.)
$!  get_command_argument(number,value,length,status,realloc=.true.)


DESCRIPTION

  Operator and function overloads have a wide range of applications
  from allowing existing Fortran routines to be used with almost no
  source-code changes to produce versions using arbitrary precision
  or cumulative error bounds on floating-point calculations to adding
  intuitive syntax for standard Fortran operations.

OVERLOADS

  //       overloads // to concatenate any two intrinsic types into a string

  ==,/=    Allow the syntax "L1 == L2"  and "L1 /= L2" where L1 and L2 are
           type LOGICAL as an alternative to the standard expressions
           "L1 .EQV. L2" and "L1 .NEQV. L2".

           It should be pointed out that

              L1 == L2   !! should be L1 .eqv. L2

           and

              L1 /= L2   !! should be L1 .neqv. L2

           should NOT work by default; but often do (probably because
           the compiler silently converts LOGICAL to INTEGER when a
           LOGICAL appears where a numeric value is required). If your
           compiler supports this non-standard (but intuitive-looking)
           syntax you can use this module to allow the syntax in a
           portable manner with a standard method.

   int(), real(), dble()  allow strings to be converted to numeric values
                          using the standard intrinsic names

   sign(value)            call sign(1,value)

$!   get_command(command,length,status_realloc=.true.)   allow "command" to be allocatable
$!
$!   get_command_argument(number,value,length,status_realloc=.true.)   allow "value"
$!                                                      to be allocatable
$!
$!   The intrinsics allow an allocated allocatable variable but do not change
$!   its allocation so to force reallocation of an allocatable variable the
$!   new logical argument "realloc" is added.

   str=merge('little','big',a.eq.10)  allows for strings of different lengths

EXAMPLES
 Sample usage:

  program demo_M_overload

   use, intrinsic :: iso_fortran_env, only : &
           & integer_kinds, int8, int16, int32, int64
   use, intrinsic :: iso_fortran_env, only : &
           & real32, real64, real128

   ! allow strings to be converted to integers
   use M_overload, only : int
   ! allow strings to be converted to floating point
   use M_overload, only : real,dble
   ! use == like .eqv.
   use M_overload, only : operator(==)
   ! use /= like .neqv.
   use M_overload, only : operator(/=)
   use M_overload, only : operator(//)
   ! take a single argument
   use M_overload, only : sign
$!   use M_overload, only : get_command
   ! allow strings of different length on merge
   use M_overload, only : merge
   ! convert logical expressions to integer
   use M_overload, only : oz, zo, lt, le, eq, ne, gt, ge
   implicit none
   character(len=:),allocatable :: cmd
   character(len=*), parameter :: gen='(*("[",g0,"]":,","))'

     ! merge() with different string lengths expanded to longest
     write(*,gen)merge('a','bbbbb',1.eq.1)
     write(*,gen)merge('a','bbbbb',1.eq.2)
     write(*,gen)merge(['a','b'],['bbbbb','ccccc'],1.eq.2)

     ! int() can take strings representing a number as input'
     if(int('1234')               .eq.1234) &
      & write(*,*)'int("STRING") works '
     ! as can real() and dble()
     if(abs(real('1234.56789') - 1234.56789).lt.2*epsilon(0.0)) &
      & write(*,*)'real("STRING") works '
     if(abs(dble('1234.5678901234567')- 1234.5678901234567d0).lt.epsilon(0.0d0)) &
      & write(*,*)'dble("STRING") works '

     ! and logical values can be treated numerically
     write(*,*) merge('int works for .FALSE.','int fails for .FALSE.',int(.FALSE.).ne.0)
     write(*,*) merge('int works for .TRUE.','int fails for .TRUE.',int(.TRUE.).eq.0)
     write(*,*) sum(int([.true.,.false.,.true.]))

     ! and == and /= work for logical expressions
     if (.true. == .true. ) &
     & write(*,*)'== works like .eqv. for LOGICAL values'
     if (.true. /= .false. ) &
     & write(*,*)'/= works like .neqv. for LOGICAL values'

     ! // will allow any intrinsic type and convert it to a string
     write(*,*)' The value is '//10//' which is less than '//20.2
     block
     character(len=:),allocatable :: fmt
     integer :: i
        i=24
        ! build a format with a variable numeric value
        fmt='("[",I'//i//',"]")'
        write(*,fmt)20
     endblock

     ! logical values as numeric values
     write(*,*) sum([int(.false.),int(.false.)])
     write(*,*) int([.false.,.true.,.false.])
     write(*,*) sum(int([.false.,.true.,.false.]))

$!     !BUG!write(*,*) sum([int([.true.,.false.])])
$! was working; no longer works with gfortran
$!     write(*,*)int(['111','222'])+333
$!     write(*,*)real(['111.111','222.222'])+333.333
$!     write(*,*)dble(['111.111d0','222.222d0'])+333.333d0
$!     write(*,*)dble([character(len=10) :: '111','222.222','333.333d0'])+444.444d0

     ! and sign() assumes the second argument is 1
     write(*,*) merge('sign works','sign fails',&
      & sign(10_int8).eq.1 &
      & .and. sign(-10_int8).eq.-1 )

$!     if(command_argument_count().eq.0)then
$!        call get_command(cmd,realloc=.true.)
$!        cmd=cmd// &
$!         &' -x -y "hello there" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
$!        call execute_command_line(cmd)
$!     else
$!        call demo_get_command()
$!        call demo_get_command_argumentA()
$!     endif
   contains

$!     subroutine demo_get_command()
$!     use M_overload, only : get_command
$!     implicit none
$!     character(len=:),allocatable :: command_line
$!        call get_command(command=command_line,realloc=.true.)
$!        write(*,'(*(g0,1x))')len(command_line),command_line
$!     end subroutine demo_get_command
$!
$!     subroutine demo_get_command_argumentA()
$!             ! alloctable and realloc=.true.
$!     use M_overload, only : get_command_argument
$!     implicit none
$!     character(len=:),allocatable :: argument
$!     integer                      :: istat, i
$!        do i=0, command_argument_count()
$!           call get_command_argument(i, argument,status=istat,&
$!            & realloc=.true.)
$!           write (*,'(2(g0,1x),"[",a,"]")') i,istat,argument
$!        enddo
$!     end subroutine demo_get_command_argumentA
$!
   end program demo_M_overload

Results:

 > [a    ]
 > [bbbbb]
 > [bbbbb],[ccccc]
 >  int("STRING") works 
 >  real("STRING") works 
 >  dble("STRING") works 
 >  int works for .FALSE.
 >  int works for .TRUE.
 >                     1
 >  == works like .eqv. for LOGICAL values
 >  /= works like .neqv. for LOGICAL values
 >   The value is 10 which is less than 20.2000008
 > [                      20]
 >                     2
 >                     1                    0                    1
 >                     2
 >  sign works

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
module m_overload
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none
$@(#) M_overload(3fm): overloads of standard operators and intrinsic procedures
private
public lt, le, eq, ne, ge, gt, oz, zo
public to
public boolean_equal, boolean_notequal      !
public operator(==)
public operator(/=)
public operator(//)
public operator(.fmt.)
public operator(.to.)
$!public int, real, dble                      ! extend intrinsics to accept CHARACTER values
$!public get_command, get_command_argument
$!public adjustl, adjustr

interface operator(.to.)
   module procedure to
end interface

interface operator ( .fmt. )
   module procedure ffmt
end interface operator ( .fmt. )

interface operator ( == )
   module procedure boolean_equal
end interface operator ( == )

interface operator ( /= )
   module procedure boolean_notequal
end interface operator ( /= )

interface operator ( // )
   module procedure g_g
end interface operator ( // )

! extend intrinsics to accept CHARACTER values
!!interface int;     module procedure int_s2v;              end interface
!!interface real;    module procedure real_s2v;             end interface
!!interface dble;    module procedure dble_s2v;             end interface
interface int;     module procedure ints_s2v;             end interface
interface real;    module procedure reals_s2v;            end interface
interface dble;    module procedure dbles_s2v;            end interface

! extend intrinsics to accept CLASS(*) arguments
interface int;     module procedure anyscalar_to_int64;   end interface
interface real;    module procedure anyscalar_to_real;    end interface
interface dble;    module procedure anyscalar_to_double;  end interface

interface sign;    module procedure sign_int8;            end interface
interface sign;    module procedure sign_int16;           end interface
interface sign;    module procedure sign_int32;           end interface
interface sign;    module procedure sign_int64;           end interface
interface sign;    module procedure sign_real32;          end interface
interface sign;    module procedure sign_real64;          end interface
#ifdef HAS_REAL128
interface sign;    module procedure sign_real128;         end interface
#endif

interface adjustl; module procedure adjustl_atleast;      end interface

interface adjustr; module procedure adjustr_atleast;      end interface

$!interface  get_command;           module  procedure  get_command_allocatable;           end  interface
$!interface  get_command_argument;  module  procedure  get_command_argument_allocatable;  end  interface

interface merge
   module procedure strmerge
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
! this allwos you to rename intrinsics, overload them, 
intrinsic :: abs,                   achar,                     acos,              acosh,             adjustl
public    :: abs,                   achar,                     acos,              acosh,             adjustl
intrinsic :: adjustr,               aimag,                     aint,              all,               allocated
public    :: adjustr,               aimag,                     aint,              all,               allocated
intrinsic :: anint,                 any,                       asin,              asinh,             associated
public    :: anint,                 any,                       asin,              asinh,             associated
intrinsic :: atan,                  atan2,                     atanh,             atomic_add,        atomic_and
public    :: atan,                  atan2,                     atanh,             atomic_add,        atomic_and
intrinsic :: atomic_cas,            atomic_define,             atomic_fetch_add,  atomic_fetch_and,  atomic_fetch_or
public    :: atomic_cas,            atomic_define,             atomic_fetch_add,  atomic_fetch_and,  atomic_fetch_or
intrinsic :: atomic_fetch_xor,      atomic_or,                 atomic_ref,        atomic_xor,        bessel_j0
public    :: atomic_fetch_xor,      atomic_or,                 atomic_ref,        atomic_xor,        bessel_j0
intrinsic :: bessel_j1,             bessel_jn,                 bessel_y0,         bessel_y1,         bessel_yn
public    :: bessel_j1,             bessel_jn,                 bessel_y0,         bessel_y1,         bessel_yn
intrinsic :: bge,                   bgt,                       bit_size,          ble,               blt
public    :: bge,                   bgt,                       bit_size,          ble,               blt
intrinsic :: btest,                 ceiling,                   char,              cmplx,             command_argument_count
public    :: btest,                 ceiling,                   char,              cmplx,             command_argument_count
intrinsic :: conjg,                 cos,                       cosh,              count,             cpu_time
public    :: conjg,                 cos,                       cosh,              count,             cpu_time
intrinsic :: cshift,                date_and_time,             dble,              digits,            dim
public    :: cshift,                date_and_time,             dble,              digits,            dim
intrinsic :: dot_product,           dprod,                     dshiftl,           dshiftr,           eoshift
public    :: dot_product,           dprod,                     dshiftl,           dshiftr,           eoshift
intrinsic :: epsilon,               erf,                       erfc,              erfc_scaled,       event_query
public    :: epsilon,               erf,                       erfc,              erfc_scaled,       event_query
intrinsic :: execute_command_line,  exp,                       exponent,          extends_type_of,   findloc
public    :: execute_command_line,  exp,                       exponent,          extends_type_of,   findloc
intrinsic :: float,                 floor,                     fraction,          gamma,             get_command
public    :: float,                 floor,                     fraction,          gamma,             get_command
intrinsic :: get_command_argument,  get_environment_variable,  huge,              hypot,             iachar
public    :: get_command_argument,  get_environment_variable,  huge,              hypot,             iachar
intrinsic :: iall,                  iand,                      iany,              ibclr,             ibits
public    :: iall,                  iand,                      iany,              ibclr,             ibits
intrinsic :: ibset,                 ichar,                     ieor,              image_index,       index
public    :: ibset,                 ichar,                     ieor,              image_index,       index
intrinsic :: int,                   ior,                       iparity,           is_contiguous,     ishft
public    :: int,                   ior,                       iparity,           is_contiguous,     ishft
intrinsic :: ishftc,                is_iostat_end,             is_iostat_eor,     kind,              lbound
public    :: ishftc,                is_iostat_end,             is_iostat_eor,     kind,              lbound
intrinsic :: leadz,                 len,                       len_trim,          lge,               lgt
public    :: leadz,                 len,                       len_trim,          lge,               lgt
intrinsic :: lle,                   llt,                       log,               log10,             log_gamma
public    :: lle,                   llt,                       log,               log10,             log_gamma
intrinsic :: logical,               maskl,                     maskr,             matmul,            max
public    :: logical,               maskl,                     maskr,             matmul,            max
intrinsic :: maxexponent,           maxloc,                    maxval,                               merge_bits
public    :: maxexponent,           maxloc,                    maxval,                               merge_bits
!intrinsic ::                                                                      merge ! ifort 2023 bug
public    ::                                                                      merge
intrinsic :: min,                   minexponent,               minloc,            minval,            mod
public    :: min,                   minexponent,               minloc,            minval,            mod
intrinsic :: modulo,                move_alloc,                mvbits,            nearest,           new_line
public    :: modulo,                move_alloc,                mvbits,            nearest,           new_line
intrinsic :: nint,                  norm2,                     not,               null,              num_images
public    :: nint,                  norm2,                     not,               null,              num_images
intrinsic :: pack,                  parity,                    popcnt,            poppar,            precision
public    :: pack,                  parity,                    popcnt,            poppar,            precision
intrinsic :: present,               product,                   radix,             random_number,     random_seed
public    :: present,               product,                   radix,             random_number,     random_seed
intrinsic :: range,                 rank,                      real,              repeat,            reshape
public    :: range,                 rank,                      real,              repeat,            reshape
intrinsic :: rrspacing,             same_type_as,              scale,             scan,              selected_char_kind
public    :: rrspacing,             same_type_as,              scale,             scan,              selected_char_kind
intrinsic :: selected_int_kind,     selected_real_kind,        set_exponent,      shape,             shifta
public    :: selected_int_kind,     selected_real_kind,        set_exponent,      shape,             shifta
intrinsic :: shiftl,                shiftr,                                       sin,               sinh
public    :: shiftl,                shiftr,                    sign,              sin,               sinh
!intrinsic ::                                                   sign ! ifort 2023 bug
intrinsic :: size,                  sngl,                      spacing,           spread,            sqrt
public    :: size,                  sngl,                      spacing,           spread,            sqrt
intrinsic :: storage_size,          sum,                       system_clock,      tan,               tanh
public    :: storage_size,          sum,                       system_clock,      tan,               tanh
intrinsic :: this_image,            tiny,                      trailz,            transfer,          transpose
public    :: this_image,            tiny,                      trailz,            transfer,          transpose
intrinsic :: trim,                  ubound,                    unpack,            verify
public    :: trim,                  ubound,                    unpack,            verify
!-----------------------------------------------------------------------------------------------------------------------------------
contains
!-----------------------------------------------------------------------------------------------------------------------------------
function g_g(value1,value2) result (string)

$@(#) M_overload::g_g(3f): convert two single intrinsic values to a string

class(*),intent(in)          :: value1, value2
character(len=:),allocatable :: string1
character(len=:),allocatable :: string2
character(len=:),allocatable :: string
   ! use this instead of str() so character variables are not trimmed and/or spaces are not added
   !ifort_bug!string = ffmt(value1,'(g0)') // ffmt(value2,'(g0)')
   string1 = ffmt(value1,'(g0)') 
   string2 = ffmt(value2,'(g0)')
   allocate(character(len=len(string1)+len(string2)) :: string)
   string(1:len(string1))=string1
   string(len(string1)+1:)=string2
end function g_g
!-----------------------------------------------------------------------------------------------------------------------------------
!x! uses // in module that redefines //. gfortran built it, ifort does not
!x!function g_g(value1,value2) result (string)
!x!
!x!$@(#) M_overload::g_g(3f): convert two single intrinsic values to a string
!x!
!x!class(*),intent(in)          :: value1, value2
!x!character(len=:),allocatable :: string
!x!   ! use this instead of str() so character variables are not trimmed and/or spaces are not added
!x!   string = ffmt(value1,'(g0)') // ffmt(value2,'(g0)')
!x!end function g_g
!-----------------------------------------------------------------------------------------------------------------------------------
elemental function strmerge(str1,str2,expr) result(strout)
!$@(#) M_strings::strmerge(3f): pads first and second arguments to MERGE(3f) to same length
character(len=*),intent(in)              :: str1
character(len=*),intent(in)              :: str2
logical,intent(in)                       :: expr
character(len=max(len(str1), len(str2))) :: strout
   if(expr)then
      strout=str1
   else
      strout=str2
   endif
end function strmerge
!-----------------------------------------------------------------------------------------------------------------------------------
function adjustl_atleast(line,length) result(strout)

$@(#) M_strings::adjustl_atleast(3f): return string padded on right to at least specified length 

character(len=*),intent(in)                :: line
integer,intent(in)                         :: length
character(len=max(length,len(trim(line)))) :: strout
   strout=adjustl(line)
end function adjustl_atleast
!-----------------------------------------------------------------------------------------------------------------------------------
function adjustr_atleast(line,length) result(strout)

$@(#) M_overload::adjustr_atleast(3f): return string padded on left to at least specified length 

character(len=*),intent(in)                :: line
integer,intent(in)                         :: length
character(len=max(length,len(trim(line)))) :: strout
   strout=line
   strout=adjustr(strout)
end function adjustr_atleast
!-----------------------------------------------------------------------------------------------------------------------------------
$PARCEL SIGN
elemental function sign_${KIND}(value)
${TYPE}(kind=${KIND}),intent(in) :: value
${TYPE}(kind=${KIND})            :: sign_${KIND}
intrinsic :: sign ! make it clear just need to call the intrinsic, not the overloaded function
   sign_${KIND}=sign(${UNIT}_${KIND},value)
end function sign_${KIND}
$ENDPARCEL

$SET TYPE real
$SET UNIT 1.0
#ifdef HAS_REAL128
$SET KIND real128
$POST SIGN
#endif
$SET KIND real64
$POST SIGN
$SET KIND real32
$POST SIGN

$SET TYPE integer
$SET UNIT 1
$SET KIND int64
$POST SIGN
$SET KIND int32
$POST SIGN
$SET KIND int16
$POST SIGN
$SET KIND int8
$POST SIGN

!-----------------------------------------------------------------------------------------------------------------------------------
logical function boolean_equal(logical_val1,logical_val2)
logical, intent (in) :: logical_val1, logical_val2

   boolean_equal = logical_val1 .eqv. logical_val2 

end function boolean_equal
!-----------------------------------------------------------------------------------------------------------------------------------
logical function boolean_notequal(logical_val1,logical_val2)
logical, intent (in) :: logical_val1, logical_val2

   boolean_notequal = logical_val1 .neqv. logical_val2

end function boolean_notequal
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!-----------------------------------------------------------------------------------------------------------------------------------
doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!-----------------------------------------------------------------------------------------------------------------------------------
real function real_s2v(chars)
character(len=*),intent(in) :: chars
intrinsic :: real ! make it clear just need to call the intrinsic, not the overloaded function
   real_s2v=real(s2v(chars))
end function real_s2v
!-----------------------------------------------------------------------------------------------------------------------------------
integer function int_s2v(chars)
character(len=*),intent(in) :: chars
intrinsic :: int ! make it clear just need to call the intrinsic, not the overloaded function
   int_s2v=int(s2v(chars))
end function int_s2v
!-----------------------------------------------------------------------------------------------------------------------------------
function ints_s2v(chars)
integer,allocatable         :: ints_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
intrinsic :: size ! make it clear just need to call the intrinsic, not an overloaded function
   isize=size(chars)
   allocate(ints_s2v(isize))
   do i=1,isize
      ints_s2v(i)=int(s2v(chars(i)))
   enddo
end function ints_s2v
!-----------------------------------------------------------------------------------------------------------------------------------
function reals_s2v(chars)
real,allocatable            :: reals_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
intrinsic :: size ! make it clear just need to call the intrinsic, not an overloaded function
   isize=size(chars)
   allocate(reals_s2v(isize))
   do i=1,isize
      reals_s2v(i)=real(s2v(chars(i)))
   enddo
end function reals_s2v
!-----------------------------------------------------------------------------------------------------------------------------------
function dbles_s2v(chars)
doubleprecision,allocatable :: dbles_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
intrinsic :: size ! make it clear just need to call the intrinsic, not an overloaded function
   isize=size(chars)
   allocate(dbles_s2v(isize))
   do i=1,isize
      dbles_s2v(i)=s2v(chars(i))
   enddo
end function dbles_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$!subroutine get_command_allocatable(command, length, status,realloc)
$!implicit none
$!!*!intrinsic get_command
$!character(len=:), allocatable, intent(out) :: COMMAND   ! (Optional) shall be of type CHARACTER and of default kind.
$!integer, intent(out), optional             :: LENGTH    ! (Optional) Shall be of type INTEGER and of default kind.
$!integer, intent(out), optional             :: STATUS    ! (Optional) Shall be of type INTEGER and of default kind.
$!logical, intent(in)                        :: realloc
$!integer                                    :: length_local
$!integer                                    :: status_local
$!logical                                    :: realloc_local
$!   realloc_local=realloc
$!   intel_bug: block
$!   intrinsic get_command
$!   call get_command(length=length_local, status=status_local)   ! get command line length
$!   if(status_local.eq.0)then
$!      if(.not.allocated(command))then
$!         allocate(character(len=length_local) :: command)          ! allocate string big enough to hold command line
$!      elseif(realloc_local)then
$!         if(allocated(command))deallocate(command)
$!         allocate(character(len=length_local) :: command)          ! allocate string big enough to hold command line
$!      endif
$!      call get_command(command=command, status=status_local)    ! get command line as a string
$!   else
$!      length_local=0
$!      command=''
$!   endif
$!   endblock intel_bug
$!   if(present(length))length=length_local
$!   if(present(status))status=status_local
$!end subroutine get_command_allocatable
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$!subroutine get_command_argument_allocatable(number, value, length, status,realloc)
$!implicit none
$!intrinsic get_command_argument
$!integer, intent(in)            :: number ! Shall be a scalar of type integer(4), NUMBER >= 0.
$!character(len=:), allocatable  :: value  ! Shall be a scalar of type CHARACTER and of default kind.
$!integer, intent(out), optional :: length ! (Optional) Shall be a scalar of type integer(4).
$!integer, intent(out), optional :: status ! (Optional) Shall be a scalar of type integer(4).
$!logical, intent(in)            :: realloc
$!integer                        :: length_local
$!integer                        :: status_local
$!logical                        :: realloc_local
$!   realloc_local=realloc
$!   call get_command_argument(number=number, length=length_local,status=status_local)
$!   if(status_local.eq.0)then
$!      if(.not.allocated(value))then
$!         allocate(character(len=length_local) :: value)          ! allocate string big enough to hold command line
$!      elseif(realloc_local)then
$!         if(allocated(value))deallocate(value)
$!         allocate(character(len=length_local) :: value)          ! allocate string big enough to hold command line
$!      endif
$!      call get_command_argument(number, value, status=status_local, length=length_local)
$!   else
$!      length_local=0
$!      value=''
$!   endif
$!   if(present(length))length=length_local
$!   if(present(status))status=status_local
$!end subroutine get_command_argument_allocatable
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function ffmt(generic,format) result (line)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128

$@(#) M_overload::ffmt(3f): convert any intrinsic to a string using specified format

class(*),intent(in)          :: generic
character(len=*),intent(in)  :: format
character(len=:),allocatable :: line
character(len=:),allocatable :: fmt_local
integer                      :: ios
character(len=255)           :: msg
character(len=1),parameter   :: nill=char(0)
integer                      :: ilen
   fmt_local=format
   ! add ",a" and print null and use position of null to find length of output
   ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ,
   ! and do not want to trim as trailing spaces can be significant
   if(fmt_local.eq.'')then
      select type(generic)
         type is (integer(kind=int8));     fmt_local='(i0,a)'
         type is (integer(kind=int16));    fmt_local='(i0,a)'
         type is (integer(kind=int32));    fmt_local='(i0,a)'
         type is (integer(kind=int64));    fmt_local='(i0,a)'
         type is (real(kind=real32));      fmt_local='(1pg0,a)'
         type is (real(kind=real64));      fmt_local='(1pg0,a)'
#ifdef HAS_REAL128
         type is (real(kind=real128));     fmt_local='(1pg0,a)'
#endif
         type is (logical);                fmt_local='(l1,a)'
         type is (character(len=*));       fmt_local='(a,a)'
         type is (complex);                fmt_local='("(",1pg0,",",1pg0,")",a)'
      end select
   else
      if(format(1:1).eq.'(')then
         fmt_local=format(:len_trim(format)-1)//',a)'
      else
         fmt_local='('//fmt_local//',a)'
      endif
   endif
   allocate(character(len=256) :: line) ! cannot currently write into allocatable variable
   ios=0
   select type(generic)
      type is (integer(kind=int8));     write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
      type is (integer(kind=int16));    write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
      type is (integer(kind=int32));    write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
      type is (integer(kind=int64));    write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
      type is (real(kind=real32));      write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
      type is (real(kind=real64));      write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
#ifdef HAS_REAL128
      type is (real(kind=real128));     write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
#endif
      type is (logical);                write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
      type is (character(len=*));       write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
      type is (complex);                write(line,fmt_local,iostat=ios,iomsg=msg) generic,nill
   end select
   if(ios.ne.0)then
      line='<ERROR>'//trim(msg)
   else
      ilen=index(line,nill,back=.true.)
      if(ilen.eq.0)ilen=len(line)
      line=line(:ilen-1)
   endif
end function ffmt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine sub_s2v(chars,valu,ierr,onerr)

!$@(#) M_strings::sub_s2v(3fp): subroutine returns double value from string

!     1989,2016 John S. Urban.
!
!  o works with any g-format input, including integer, real, and exponential.
!  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o onerr -- value to use if an error occurs

character(len=*),intent(in)  :: chars                     ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                      ! value read from input string
integer,intent(out)          :: ierr                      ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr

character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"  ! format used to build frmt
character(len=15)            :: frmt                      ! holds format built to read input string
character(len=256)           :: msg                       ! hold message from I/O errors
character(len=3),save        :: nan_string='NaN'

   ierr=0                                                 ! initialize error flag to zero
   local_chars=chars
   msg=''
   if(len(local_chars).eq.0)local_chars=' '
   write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
   read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
   if(ierr.ne.0)then                                      ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      write(*,*)'*s2v* - cannot produce number from string ['//trim(chars)//']'
      if(msg.ne.'')then
         write(*,*)'*s2v* - ['//trim(msg)//']'
      endif
   endif
end subroutine sub_s2v
!===================================================================================================================================
function s2v(string) result (value)
character(len=*),intent(in) :: string
doubleprecision             :: value
integer                     :: ierr, onerr
   call sub_s2v(string,value,ierr)! , ierr, onerr)
end function s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function atleast(line,length,pattern) result(strout)

!$@(#) M_overload::atleast(3f): return string padded to at least specified length

character(len=*),intent(in)                :: line
integer,intent(in)                         :: length
character(len=*),intent(in),optional       :: pattern
character(len=max(length,len(trim(line)))) :: strout
if(present(pattern))then
   strout=line//repeat(pattern,len(strout)/len(pattern)+1)
else
   strout=line
endif
end function atleast
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
pure elemental function anyscalar_to_double(valuein) result(d_out)
use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit
implicit none
intrinsic dble

$@(#) M_overload::anyscalar_to_double(3f): convert integer or real parameter of any kind to doubleprecision

class(*),intent(in)       :: valuein
doubleprecision           :: d_out
doubleprecision,parameter :: big=huge(0.0d0)
   select type(valuein)
   type is (integer(kind=int8));   d_out=dble(valuein)
   type is (integer(kind=int16));  d_out=dble(valuein)
   type is (integer(kind=int32));  d_out=dble(valuein)
   type is (integer(kind=int64));  d_out=dble(valuein)
   type is (real(kind=real32));    d_out=dble(valuein)
   type is (real(kind=real64));    d_out=dble(valuein)
#ifdef HAS_REAL128
   type is (real(kind=real128))
      !!if(valuein.gt.big)then
      !!   write(error_unit,*)'*anyscalar_to_double* value too large ',valuein
      !!endif
      d_out=dble(valuein)
#endif
   type is (logical);              d_out=merge(0.0d0,1.0d0,valuein)
   type is (character(len=*));      read(valuein,*) d_out
   class default
     d_out=0.0d0
     !!stop '*M_overload::anyscalar_to_double: unknown type'
   end select
end function anyscalar_to_double
!===================================================================================================================================
impure elemental function anyscalar_to_int64(valuein) result(ii38)
use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit
implicit none
intrinsic int

$@(#) M_overload::anyscalar_to_int64(3f): convert integer parameter of any kind to 64-bit integer

class(*),intent(in)    :: valuein
   integer(kind=int64) :: ii38
   integer             :: ios
   character(len=256)  :: message
   select type(valuein)
   type is (integer(kind=int8));   ii38=int(valuein,kind=int64)
   type is (integer(kind=int16));  ii38=int(valuein,kind=int64)
   type is (integer(kind=int32));  ii38=valuein
   type is (integer(kind=int64));  ii38=valuein
   type is (real(kind=real32));    ii38=int(valuein,kind=int64)
   type is (real(kind=real64));    ii38=int(valuein,kind=int64)
#ifdef HAS_REAL128
   Type is (real(kind=real128));   ii38=int(valuein,kind=int64)
#endif
   type is (logical);              ii38=merge(0_int64,1_int64,valuein)
   type is (character(len=*))   ;
      read(valuein,*,iostat=ios,iomsg=message)ii38
      if(ios.ne.0)then
         write(error_unit,*)'*anyscalar_to_int64* ERROR: '//trim(message)
         stop 2
      endif
   class default
      write(error_unit,*)'*anyscalar_to_int64* ERROR: unknown integer type'
      stop 3
   end select
end function anyscalar_to_int64
!===================================================================================================================================
pure elemental function anyscalar_to_real(valuein) result(r_out)
use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit
implicit none
intrinsic real

$@(#) M_overload::anyscalar_to_real(3f): convert integer or real parameter of any kind to real

class(*),intent(in) :: valuein
real                :: r_out
real,parameter      :: big=huge(0.0)
   select type(valuein)
   type is (integer(kind=int8));   r_out=real(valuein)
   type is (integer(kind=int16));  r_out=real(valuein)
   type is (integer(kind=int32));  r_out=real(valuein)
   type is (integer(kind=int64));  r_out=real(valuein)
   type is (real(kind=real32));    r_out=real(valuein)
   type is (real(kind=real64))
      !!if(valuein.gt.big)then
      !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein
      !!endif
      r_out=real(valuein)
#ifdef HAS_REAL128
   type is (real(kind=real128))
      !!if(valuein.gt.big)then
      !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein
      !!endif
      r_out=real(valuein)
#endif
   type is (logical);              r_out=merge(0.0d0,1.0d0,valuein)
   type is (character(len=*));     read(valuein,*) r_out
   end select
end function anyscalar_to_real
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file to.3m_overload.man
NAME
   to(3f) - [M_overload::LOGICAL] return array of adjacent integers over specified range, inclusive
   (LICENSE:PD)
SYNOPSIS

   pure elemental integer function to(i,j)

    integer,intent(in) :: i
    integer,intent(in) :: j
    integer,allocatable :: to

DESCRIPTION

    A convenience for expressing [(integer :: i=N,M)]

OPTIONS
   I  starting value
   J  ending value

RETURNS

   An array of adjacent whole numbers from I to J

EXAMPLES
 Sample usage:

   program demo_to
   use M_overload, only: to, operator(.to.)
   implicit none
      print*,[11.to.16]
      print*,2.5 * [1.to.4]
      print*,2.5 * to(1,4)+10
   end program demo_to

AUTHOR
   John S. Urban, inspired by @beliavsky
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
pure function to(i, j) result(vec)
integer, intent(in) :: i, j
integer             :: vec(j-i+1)
integer             :: k
if(i.le.j)then
   vec = [(k, k=i,j)]
else
   vec = [(k, k=i,j,-1)]
endif
end function to
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file oz.3m_overload.man
NAME
   oz(3f) - [M_overload::LOGICAL] returns One if expression is TRUE, else returns Zero.
   (LICENSE:PD)
SYNOPSIS

   pure elemental integer function oz(expr)

    logical,intent(in) :: expr

DESCRIPTION

   Returns an integer given a logical expression.

OPTIONS
   expr  A logical expression

RETURNS

   The result is a default INTEGER value of 1 if the expression is TRUE,
   and a 0 otherwise.

EXAMPLES
 Sample usage:

   program demo_oz
   use M_overload, only: oz, zo, lt, le, eq, ne, gt, ge
   implicit none
      write (*, *) 'is 10 < 20 ?', oz(10 < 20)
      write (*, *) 'elemental', oz([2 > 1, 3 == 4, 10 < 5, 100 > 50])
      if (sum(oz([2 > 1, 3 == 4, 10 < 5, 100 > 50])) >= 2) then
         write (*, *) 'two or more are true'
      endif
   end program demo_oz

 Results:

    > is 10 < 20 ? 1
    > elemental 1 0 0 1
    > two or more are true

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
pure elemental integer function oz(expr) 
$@(#) M_strings::oz(3f): logical to integer, TRUE results in 1, FALSE results in 0
logical, intent(in) :: expr
   oz = merge(1, 0, expr) ! One and Zero
end function oz

$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file zo.3m_overload.man
NAME
   zo(3f) - [M_overload::LOGICAL] returns Zero if expression is FALSE, else returns One.
   (LICENSE:PD)
SYNOPSIS

   pure elemental integer function zo(expr)

    logical,intent(in) :: expr

DESCRIPTION

   Returns an integer given a logical expression.

OPTIONS
   expr  A logical expression

RETURNS

   The result is a default INTEGER value of 0 if the expression is TRUE,
   and a 1 otherwise.

EXAMPLES
 Sample usage:

   program demo_zo
   use M_overload, only: zo, zo, lt, le, eq, ne, gt, ge
   implicit none
   write (*, *) zo(10 < 20)
   if (sum(zo([1 > 2, 3 == 4, 10 < 5, 100 > 50])) > 2) then
      write (*, *) 'two or more are not true'
   endif
   end program demo_zo

 Results:

   >           0
   >  two or more are not true

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
pure elemental integer function zo(expr) 
$@(#) M_strings::zo(3f): logical to integer, TRUE results in 0, FALSE results in 1
logical, intent(in) :: expr
   zo = merge(0, 1, expr) ! Zero and One
end function zo

pure elemental integer function ge(ia,ib) 
$@(#) M_strings::ge(3f): logical to integer, TRUE results in 0, FALSE results in 1
integer,intent(in)  :: ia, ib
   ge = merge(1, 0, ia .ge. ib )
end function ge

pure elemental integer function le(ia,ib) 
$@(#) M_strings::le(3f): logical to integer, TRUE results in 0, FALSE results in 1
integer,intent(in)  :: ia, ib
   le = merge(1, 0, ia .le. ib )
end function le

pure elemental integer function eq(ia,ib) 
$@(#) M_strings::eq(3f): logical to integer, TRUE results in 0, FALSE results in 1
integer,intent(in)  :: ia, ib
   eq = merge(1, 0, ia .eq. ib )
end function eq

pure elemental integer function lt(ia,ib) 
$@(#) M_strings::lt(3f): logical to integer, TRUE results in 0, FALSE results in 1
integer,intent(in)  :: ia, ib
   lt = merge(1, 0, ia .lt. ib )
end function lt

pure elemental integer function gt(ia,ib) 
$@(#) M_strings::gt(3f): logical to integer, TRUE results in 0, FALSE results in 1
integer,intent(in)  :: ia, ib
   gt = merge(1, 0, ia .lt. ib )
end function gt

pure elemental integer function ne(ia,ib) 
$@(#) M_strings::ne(3f): logical to integer, TRUE results in 0, FALSE results in 1
integer,intent(in)  :: ia, ib
   ne = merge(1, 0, ia .lt. ib )
end function ne
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_overload
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
!
! THOSE features would make interesting additions to the Fortran standard.
!
!
!-----------------------------------------------------

! An example of overloading subroutines.
! by James Van Buskirk as posted at comp.lang.fortran on 24 September
! 2007.
! This says to me that the code as given was nonconforming because the
! name FOO was used to identify the module procedure SUBROUTINE FOO
! from MODULE M1 as well as the module procedure SUBROUTINE FOO from
! MODULE M2.  The case of generic names says to me that any number of
! generic identifiers may have the same name as one module procedure
! provided any possible generic procedure reference is unambiguous
! (section 14.1.2.3).

MODULE M1
   INTERFACE FOO1
     MODULE PROCEDURE joe
   END INTERFACE

   INTERFACE FOO2
     MODULE PROCEDURE sue
   END INTERFACE
CONTAINS
   SUBROUTINE joe(I,I2,extra)
     integer extra
     INTEGER, INTENT(IN) :: I, I2
     WRITE(*,*) 'Joe INTEGER'
   END SUBROUTINE joe

   SUBROUTINE sue(I,I2,extra,onemore)
     integer extra, onemore
     INTEGER, INTENT(IN) :: I, I2
     WRITE(*,*) 'Sue INTEGER'
   END SUBROUTINE sue
END MODULE M1

MODULE M2
   INTERFACE FOO1
     MODULE PROCEDURE joe
   END INTERFACE

   INTERFACE FOO2
     MODULE PROCEDURE sue
   END INTERFACE
CONTAINS
   SUBROUTINE joe(R,R2,extra)
     integer extra
     REAL, INTENT(IN) :: R,R2
     WRITE(*,*) 'Joe REAL'
   END SUBROUTINE joe

   SUBROUTINE sue(R,R2,extra,onemore)
     integer extra, onemore
     REAL, INTENT(IN) :: R,R2
     WRITE(*,*) 'Sue REAL'
   END SUBROUTINE sue
END MODULE M2

MODULE M3
   INTERFACE FOO1
     MODULE PROCEDURE joe
   END INTERFACE

   INTERFACE FOO2
     MODULE PROCEDURE sue
   END INTERFACE
CONTAINS
   SUBROUTINE joe(D,D2,extra)
     integer extra
     DOUBLE PRECISION, INTENT(IN) :: D,D2
     WRITE(*,*) 'Joe DOUBLE'
   END SUBROUTINE joe

   SUBROUTINE sue(D,D2,extra,onemore)
     integer extra, onemore
     DOUBLE PRECISION, INTENT(IN) :: D,D2
     WRITE(*,*) 'Sue DOUBLE'
   END SUBROUTINE sue
END MODULE M3

program p
! In PROGRAM P, there are three class 2 entities with the names 'joe',
! and sue; 'joe' and 'sue' are not generic names.
   use m1
   use m2
   use m3
   call foo1(10,9,1)
   call foo1(10.,9.,1)
   call foo1(10.0d0,9.0d0,1)

   call foo2(10,9,2,3)
   call foo2(10.,9.,2,3)
   call foo2(10.0d0,9.0d0,2,3)

end program p
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
