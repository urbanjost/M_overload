var tipuesearch = {"pages":[{"title":" M_overload ","text":"M_overload Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_overload.f90 – M_overload","text":"Contents Modules m_overload Source Code M_overload.f90 Source Code !> !!##NAME !!    M_overload(3fm) - [M_overload] overloads of standard operators and intrinsic procedures !!    (LICENSE:PD) !!##SYNOPSIS !! !!  overloads on LOGICAL values !! !!    ! use == like .eqv.; ie. logical==logical !!    use M_overload, only : operator(==) !!    ! use /= like .neqv.; ie. logical/=logical !!    use M_overload, only : operator(/=) !! !!  overloads on INTRINSICS to take strings, logicals, and metamorphic numeric intrinsic values !! !!   use M_overload, only : int, real, dble !!   ! int('string')   int(logical)   int(class(*)) !!   ! real('string')  real(logical)  real(class(*)) !!   ! dble('string')  dble(logical)  dble(class(*)) !! !!  overloads on operators !! !!   use M_overload, only : operator(==) !!   ! INTRINSIC // INTRINSIC // INTRINSIC ... !! !!   ! When sign(3f) is given a single value, call sign(1,value); ie.  sign(value) !!   use M_overload, only : sign !! !! !!  Allow strings of different length in MERGE !! !!   use M_overload, only : merge !!   ! str=merge('one','three',i.eq.10) !! !!##OTHER OPERATORS !! !!    intrinsic_value .fmt. ''   convert an intrinsic value to a CHARACTER variable !! !!##DESCRIPTION !! !!   Operator and function overloads have a wide range of applications !!   from allowing existing Fortran routines to be used with almost no !!   source-code changes to produce versions using arbitrary precision !!   or cumulative error bounds on floating-point calculations to adding !!   intuitive syntax for standard Fortran operations. !! !!##OVERLOADS !! !!   //       overloads // to concatenate any two intrinsic types into a string !! !!   ==,/=    Allow the syntax \"L1 == L2\"  and \"L1 /= L2\" where L1 and L2 are !!            type LOGICAL as an alternative to the standard expressions !!            \"L1 .EQV. L2\" and \"L1 .NEQV. L2\". !! !!            It should be pointed out that !! !!               L1 == L2   !! should be L1 .eqv. L2 !! !!            and !! !!               L1 /= L2   !! should be L1 .neqv. L2 !! !!            should NOT work by default; but often do (probably because !!            the compiler silently converts LOGICAL to INTEGER when a !!            LOGICAL appears where a numeric value is required). If your !!            compiler supports this non-standard (but intuitive-looking) !!            syntax you can use this module to allow the syntax in a !!            portable manner with a standard method. !! !!    int(), real(), dble()  allow strings to be converted to numeric values !!                           using the standard intrinsic names !! !!    sign(value)            call sign(1,value) !! !! !!    str=merge('little','big',a.eq.10)  allows for strings of different lengths !! !!##EXAMPLES !! !!  Sample usage: !! !!   program demo_M_overload !! !!    use, intrinsic :: iso_fortran_env, only : & !!            & integer_kinds, int8, int16, int32, int64 !!    use, intrinsic :: iso_fortran_env, only : & !!            & real32, real64, real128 !! !!    ! allow strings to be converted to integers !!    use M_overload, only : int !!    ! allow strings to be converted to floating point !!    use M_overload, only : real,dble !!    ! use == like .eqv. !!    use M_overload, only : operator(==) !!    ! use /= like .neqv. !!    use M_overload, only : operator(/=) !!    use M_overload, only : operator(//) !!    ! take a single argument !!    use M_overload, only : sign !!    ! allow strings of different length on merge !!    use M_overload, only : merge !!    implicit none !!    character(len=:),allocatable :: cmd !!    character(len=*), parameter :: gen='(*(\"[\",g0,\"]\":,\",\"))' !! !!      write(*,gen)merge('a','bbbbb',1.eq.1) !!      write(*,gen)merge('a','bbbbb',1.eq.2) !!      write(*,gen)merge(['a','b'],['bbbbb','ccccc'],1.eq.2) !! !!      if(int('1234')               .eq.1234) & !!       & write(*,*)'int(\"STRING\") works ' !!      if(abs(real('1234.56789') - 1234.56789).lt.2*epsilon(0.0)) & !!       & write(*,*)'real(\"STRING\") works ' !!      if(abs(dble('1234.5678901234567')- 1234.5678901234567d0).lt.epsilon(0.0d0)) & !!       & write(*,*)'dble(\"STRING\") works ' !! !!       if (.true. == .true. ) & !!       & write(*,*)'== works like .eqv. for LOGICAL values' !!      if (.true. /= .false. ) & !!       & write(*,*)'/= works like .neqv. for LOGICAL values' !! !!       write(*,*)' The value is '//10//' which is less than '//20.2 !! !! !!      write(*,*) merge('sign works','sign fails',& !!             & sign(10_int8).eq.1 & !!       & .and. sign(-10_int8).eq.-1 ) !!      write(*,*) merge('sign works','sign fails',& !!             & sign(10_int16).eq.1 & !!       & .and. sign(-10_int16).eq.-1 ) !!      write(*,*) merge('sign works','sign fails',& !!             & sign(10_int32).eq.1 & !!       & .and. sign(-10_int32).eq.-1 ) !!      write(*,*) merge('sign works','sign fails',& !!             & sign(10_int64).eq.1 & !!       & .and. sign(-10_int64).eq.-1 ) !!      write(*,*) merge('sign works','sign fails',& !!             & sign(10.0_real32).eq.1.0 & !!       & .and. sign(-10.0_real32).eq.-1.0 ) !!      write(*,*) merge('sign works','sign fails',& !!             & sign(10.0_real64).eq.1.0 & !!       & .and. sign(-10.0_real64).eq.-1.0 ) !!      write(*,*) merge('sign works','sign fails',& !!       & sign(10.0_real128).eq.1.0& !!       & .and. sign(-10.0_real128).eq.-1.0 ) !!    contains !! !!    end program demo_M_overload !! !!  Results: !!     >  [a    ] !!     >  [bbbbb] !!     >  [bbbbb],[ccccc] !!     >  int(\"STRING\") works !!     >  real(\"STRING\") works !!     >  dble(\"STRING\") works !!     >  == works like .eqv. for LOGICAL values !!     >  /= works like .neqv. for LOGICAL values !!     >          444         555 !!     >    444.444000       555.554993 !!     >    444.44400000000002        555.55500000000006 !!     >    555.44399999999996        666.66600000000005        777.77700000000004 !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     >  int(\"STRING\") works !!     >  real(\"STRING\") works !!     >  dble(\"STRING\") works !!     >  == works like .eqv. for LOGICAL values !!     >  /= works like .neqv. for LOGICAL values !!     >          444         555 !!     >    444.444000       555.554993 !!     >    444.44400000000002        555.55500000000006 !!     >    555.44399999999996        666.66600000000005        777.77700000000004 !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     >  sign works !!     > 57 xx -x -y hello there xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx !!     > 0 0 [xx] !!     > 1 0 [-x] !!     > 2 0 [-y] !!     > 3 0 [hello there] !!     > 4 0 [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] !!     > 0 0 [xx        ] !!     > 1 0 [-x        ] !!     > 2 0 [-y        ] !!     > 3 -1 [hello ther] !!     > 4 -1 [xxxxxxxxxx] !!     > 0 0 [xx                  ] !!     > 1 0 [-x                  ] !!     > 2 0 [-y                  ] !!     > 3 0 [hello there         ] !!     > 4 -1 [xxxxxxxxxxxxxxxxxxxx] !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain module m_overload use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none ! ident_1=\"@(#)M_overload(3fm): overloads of standard operators and intrinsic procedures\" private public boolean_equal , boolean_notequal ! public operator ( == ) public operator ( /= ) public operator ( // ) public operator (. fmt .) public int , real , dble ! extend intrinsics to accept CHARACTER values public sign public adjustl , adjustr public merge interface operator ( . fmt . ) module procedure ffmt end interface operator ( . fmt . ) interface operator ( == ) module procedure boolean_equal end interface operator ( == ) interface operator ( /= ) module procedure boolean_notequal end interface operator ( /= ) interface operator ( // ) module procedure g_g end interface operator ( // ) ! extend intrinsics to accept CHARACTER values !!interface int;     module procedure int_s2v;              end interface !!interface real;    module procedure real_s2v;             end interface !!interface dble;    module procedure dble_s2v;             end interface interface int ; module procedure ints_s2v ; end interface interface real ; module procedure reals_s2v ; end interface interface dble ; module procedure dbles_s2v ; end interface ! extend intrinsics to accept CLASS(*) arguments interface int ; module procedure anyscalar_to_int64 ; end interface interface real ; module procedure anyscalar_to_real ; end interface interface dble ; module procedure anyscalar_to_double ; end interface interface sign ; module procedure sign_int8 ; end interface interface sign ; module procedure sign_int16 ; end interface interface sign ; module procedure sign_int32 ; end interface interface sign ; module procedure sign_int64 ; end interface interface sign ; module procedure sign_real32 ; end interface interface sign ; module procedure sign_real64 ; end interface interface sign ; module procedure sign_real128 ; end interface interface adjustl ; module procedure adjustl_atleast ; end interface interface adjustr ; module procedure adjustr_atleast ; end interface interface merge ; module procedure strmerge ; end interface contains !----------------------------------------------------------------------------------------------------------------------------------- function g_g ( value1 , value2 ) result ( string ) ! ident_2=\"@(#)M_overload::g_g(3f): convert two single intrinsic values to a string\" class ( * ), intent ( in ) :: value1 , value2 character ( len = :), allocatable :: string1 character ( len = :), allocatable :: string2 character ( len = :), allocatable :: string ! use this instead of str() so character variables are not trimmed and/or spaces are not added !ifort_bug!string = ffmt(value1,'(g0)') // ffmt(value2,'(g0)') string1 = ffmt ( value1 , '(g0)' ) string2 = ffmt ( value2 , '(g0)' ) allocate ( character ( len = len ( string1 ) + len ( string2 )) :: string ) string ( 1 : len ( string1 )) = string1 string ( len ( string1 ) + 1 :) = string2 end function g_g !----------------------------------------------------------------------------------------------------------------------------------- !x! uses // in module that redefines //. gfortran built it, ifort does not !x!function g_g(value1,value2) result (string) !x! !x!$@(#) M_overload::g_g(3f): convert two single intrinsic values to a string !x! !x!class(*),intent(in)          :: value1, value2 !x!character(len=:),allocatable :: string !x!   ! use this instead of str() so character variables are not trimmed and/or spaces are not added !x!   string = ffmt(value1,'(g0)') // ffmt(value2,'(g0)') !x!end function g_g !----------------------------------------------------------------------------------------------------------------------------------- elemental function strmerge ( str1 , str2 , expr ) result ( strout ) !$@(#) M_strings::strmerge(3f): pads first and second arguments to MERGE(3f) to same length character ( len =* ), intent ( in ) :: str1 character ( len =* ), intent ( in ) :: str2 logical , intent ( in ) :: expr character ( len = max ( len ( str1 ), len ( str2 ))) :: strout if ( expr ) then strout = str1 else strout = str2 endif end function strmerge !----------------------------------------------------------------------------------------------------------------------------------- function adjustl_atleast ( line , length ) result ( strout ) ! ident_3=\"@(#)M_strings::adjustl_atleast(3f): return string padded on right to at least specified length\" character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len = max ( length , len ( trim ( line )))) :: strout strout = adjustl ( line ) end function adjustl_atleast !----------------------------------------------------------------------------------------------------------------------------------- function adjustr_atleast ( line , length ) result ( strout ) ! ident_4=\"@(#)M_overload::adjustr_atleast(3f): return string padded on left to at least specified length\" character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len = max ( length , len ( trim ( line )))) :: strout strout = line strout = adjustr ( strout ) end function adjustr_atleast !----------------------------------------------------------------------------------------------------------------------------------- elemental function sign_real128 ( value ) real ( kind = real128 ), intent ( in ) :: value real ( kind = real128 ) :: sign_real128 sign_real128 = sign ( 1.0_real128 , value ) end function sign_real128 elemental function sign_real64 ( value ) real ( kind = real64 ), intent ( in ) :: value real ( kind = real64 ) :: sign_real64 sign_real64 = sign ( 1.0_real64 , value ) end function sign_real64 elemental function sign_real32 ( value ) real ( kind = real32 ), intent ( in ) :: value real ( kind = real32 ) :: sign_real32 sign_real32 = sign ( 1.0_real32 , value ) end function sign_real32 elemental function sign_int64 ( value ) integer ( kind = int64 ), intent ( in ) :: value integer ( kind = int64 ) :: sign_int64 sign_int64 = sign ( 1_int64 , value ) end function sign_int64 elemental function sign_int32 ( value ) integer ( kind = int32 ), intent ( in ) :: value integer ( kind = int32 ) :: sign_int32 sign_int32 = sign ( 1_int32 , value ) end function sign_int32 elemental function sign_int16 ( value ) integer ( kind = int16 ), intent ( in ) :: value integer ( kind = int16 ) :: sign_int16 sign_int16 = sign ( 1_int16 , value ) end function sign_int16 elemental function sign_int8 ( value ) integer ( kind = int8 ), intent ( in ) :: value integer ( kind = int8 ) :: sign_int8 sign_int8 = sign ( 1_int8 , value ) end function sign_int8 !----------------------------------------------------------------------------------------------------------------------------------- logical function boolean_equal ( logical_val1 , logical_val2 ) logical , intent ( in ) :: logical_val1 logical , intent ( in ) :: logical_val2 if ( logical_val1 . eqv . logical_val2 ) then boolean_equal = . true . else boolean_equal = . false . endif end function boolean_equal !----------------------------------------------------------------------------------------------------------------------------------- logical function boolean_notequal ( logical_val1 , logical_val2 ) logical , intent ( in ) :: logical_val1 logical , intent ( in ) :: logical_val2 if ( logical_val1 . eqv . logical_val2 ) then boolean_notequal = . false . else boolean_notequal = . true . endif end function boolean_notequal !=================================================================================================================================== ! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f) !----------------------------------------------------------------------------------------------------------------------------------- doubleprecision function dble_s2v ( chars ) character ( len =* ), intent ( in ) :: chars dble_s2v = s2v ( chars ) end function dble_s2v !----------------------------------------------------------------------------------------------------------------------------------- real function real_s2v ( chars ) character ( len =* ), intent ( in ) :: chars real_s2v = real ( s2v ( chars )) end function real_s2v !----------------------------------------------------------------------------------------------------------------------------------- integer function int_s2v ( chars ) character ( len =* ), intent ( in ) :: chars int_s2v = int ( s2v ( chars )) end function int_s2v !----------------------------------------------------------------------------------------------------------------------------------- function ints_s2v ( chars ) integer , allocatable :: ints_s2v (:) character ( len =* ), intent ( in ) :: chars (:) integer :: i , isize isize = size ( chars ) allocate ( ints_s2v ( isize )) do i = 1 , isize ints_s2v ( i ) = int ( s2v ( chars ( i ))) enddo end function ints_s2v !----------------------------------------------------------------------------------------------------------------------------------- function reals_s2v ( chars ) real , allocatable :: reals_s2v (:) character ( len =* ), intent ( in ) :: chars (:) integer :: i , isize isize = size ( chars ) allocate ( reals_s2v ( isize )) do i = 1 , isize reals_s2v ( i ) = real ( s2v ( chars ( i ))) enddo end function reals_s2v !----------------------------------------------------------------------------------------------------------------------------------- function dbles_s2v ( chars ) doubleprecision , allocatable :: dbles_s2v (:) character ( len =* ), intent ( in ) :: chars (:) integer :: i , isize isize = size ( chars ) allocate ( dbles_s2v ( isize )) do i = 1 , isize dbles_s2v ( i ) = s2v ( chars ( i )) enddo end function dbles_s2v !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function ffmt ( generic , format ) result ( line ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 ! ident_5=\"@(#)M_overload::ffmt(3f): convert any intrinsic to a string using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: line character ( len = :), allocatable :: fmt_local integer :: ios character ( len = 255 ) :: msg character ( len = 1 ), parameter :: nill = char ( 0 ) integer :: ilen fmt_local = format ! add \",a\" and print null and use position of null to find length of output ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ, ! and do not want to trim as trailing spaces can be significant if ( fmt_local . eq . '' ) then select type ( generic ) type is ( integer ( kind = int8 )); fmt_local = '(i0,a)' type is ( integer ( kind = int16 )); fmt_local = '(i0,a)' type is ( integer ( kind = int32 )); fmt_local = '(i0,a)' type is ( integer ( kind = int64 )); fmt_local = '(i0,a)' type is ( real ( kind = real32 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real64 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real128 )); fmt_local = '(1pg0,a)' type is ( logical ); fmt_local = '(l1,a)' type is ( character ( len =* )); fmt_local = '(a,a)' type is ( complex ); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' end select else if ( format ( 1 : 1 ). eq . '(' ) then fmt_local = format (: len_trim ( format ) - 1 ) // ',a)' else fmt_local = '(' // fmt_local // ',a)' endif endif allocate ( character ( len = 256 ) :: line ) ! cannot currently write into allocatable variable ios = 0 select type ( generic ) type is ( integer ( kind = int8 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( integer ( kind = int16 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( integer ( kind = int32 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( integer ( kind = int64 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( real ( kind = real32 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( real ( kind = real64 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( real ( kind = real128 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( logical ); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( character ( len =* )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill type is ( complex ); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , nill end select if ( ios . ne . 0 ) then line = '<ERROR>' // trim ( msg ) else ilen = index ( line , nill , back = . true .) if ( ilen . eq . 0 ) ilen = len ( line ) line = line (: ilen - 1 ) endif end function ffmt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sub_s2v ( chars , valu , ierr , onerr ) !$@(#) M_strings::sub_s2v(3fp): subroutine returns double value from string !     1989,2016 John S. Urban. ! !  o works with any g-format input, including integer, real, and exponential. !  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0. !  o onerr -- value to use if an error occurs character ( len =* ), intent ( in ) :: chars ! input string character ( len = :), allocatable :: local_chars doubleprecision , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) class ( * ), optional , intent ( in ) :: onerr character ( len =* ), parameter :: fmt = \"('(bn,g',i5,'.0)')\" ! format used to build frmt character ( len = 15 ) :: frmt ! holds format built to read input string character ( len = 256 ) :: msg ! hold message from I/O errors character ( len = 3 ), save :: nan_string = 'NaN' ierr = 0 ! initialize error flag to zero local_chars = chars msg = '' if ( len ( local_chars ). eq . 0 ) local_chars = ' ' write ( frmt , fmt ) len ( local_chars ) ! build format of form '(BN,Gn.0)' read ( local_chars , fmt = frmt , iostat = ierr , iomsg = msg ) valu ! try to read value from string if ( ierr . ne . 0 ) then ! if an error occurred ierr will be non-zero. if ( present ( onerr )) then select type ( onerr ) type is ( integer ) valu = onerr type is ( real ) valu = onerr type is ( doubleprecision ) valu = onerr end select else ! set return value to NaN read ( nan_string , '(g3.3)' ) valu endif write ( * , * ) '*s2v* - cannot produce number from string [' // trim ( chars ) // ']' if ( msg . ne . '' ) then write ( * , * ) '*s2v* - [' // trim ( msg ) // ']' endif endif end subroutine sub_s2v !=================================================================================================================================== function s2v ( string ) result ( value ) character ( len =* ), intent ( in ) :: string doubleprecision :: value integer :: ierr , onerr call sub_s2v ( string , value , ierr ) ! , ierr, onerr) end function s2v !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function atleast ( line , length , pattern ) result ( strout ) !$@(#) M_overload::atleast(3f): return string padded to at least specified length character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len =* ), intent ( in ), optional :: pattern character ( len = max ( length , len ( trim ( line )))) :: strout if ( present ( pattern )) then strout = line // repeat ( pattern , len ( strout ) / len ( pattern ) + 1 ) else strout = line endif end function atleast !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== pure elemental function anyscalar_to_double ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none intrinsic dble ! ident_6=\"@(#)M_anything::anyscalar_to_double(3f): convert integer or real parameter of any kind to doubleprecision\" class ( * ), intent ( in ) :: valuein doubleprecision :: d_out doubleprecision , parameter :: big = huge ( 0.0d0 ) select type ( valuein ) type is ( integer ( kind = int8 )); d_out = dble ( valuein ) type is ( integer ( kind = int16 )); d_out = dble ( valuein ) type is ( integer ( kind = int32 )); d_out = dble ( valuein ) type is ( integer ( kind = int64 )); d_out = dble ( valuein ) type is ( real ( kind = real32 )); d_out = dble ( valuein ) type is ( real ( kind = real64 )); d_out = dble ( valuein ) Type is ( real ( kind = real128 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !!endif d_out = dble ( valuein ) type is ( logical ); d_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out !type is (real(kind=real128)) !   if(valuein.gt.big)then !      write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !   endif !   d_out=dble(valuein) class default d_out = 0.0d0 !!stop '*M_anything::anyscalar_to_double: unknown type' end select end function anyscalar_to_double !=================================================================================================================================== impure elemental function anyscalar_to_int64 ( valuein ) result ( ii38 ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none intrinsic int ! ident_7=\"@(#)M_anything::anyscalar_to_int64(3f): convert integer parameter of any kind to 64-bit integer\" class ( * ), intent ( in ) :: valuein integer ( kind = int64 ) :: ii38 integer :: ios character ( len = 256 ) :: message select type ( valuein ) type is ( integer ( kind = int8 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int16 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int32 )); ii38 = valuein type is ( integer ( kind = int64 )); ii38 = valuein type is ( real ( kind = real32 )); ii38 = int ( valuein , kind = int64 ) type is ( real ( kind = real64 )); ii38 = int ( valuein , kind = int64 ) Type is ( real ( kind = real128 )); ii38 = int ( valuein , kind = int64 ) type is ( logical ); ii38 = merge ( 0_int64 , 1_int64 , valuein ) type is ( character ( len =* )) ; read ( valuein , * , iostat = ios , iomsg = message ) ii38 if ( ios . ne . 0 ) then write ( error_unit , * ) '*anyscalar_to_int64* ERROR: ' // trim ( message ) stop 2 endif class default write ( error_unit , * ) '*anyscalar_to_int64* ERROR: unknown integer type' stop 3 end select end function anyscalar_to_int64 !=================================================================================================================================== pure elemental function anyscalar_to_real ( valuein ) result ( r_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none intrinsic real ! ident_8=\"@(#)M_anything::anyscalar_to_real(3f): convert integer or real parameter of any kind to real\" class ( * ), intent ( in ) :: valuein real :: r_out real , parameter :: big = huge ( 0.0 ) select type ( valuein ) type is ( integer ( kind = int8 )); r_out = real ( valuein ) type is ( integer ( kind = int16 )); r_out = real ( valuein ) type is ( integer ( kind = int32 )); r_out = real ( valuein ) type is ( integer ( kind = int64 )); r_out = real ( valuein ) type is ( real ( kind = real32 )); r_out = real ( valuein ) type is ( real ( kind = real64 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) type is ( real ( kind = real128 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) type is ( logical ); r_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) r_out !type is (real(kind=real128));  r_out=real(valuein) end select end function anyscalar_to_real !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end module M_overload","tags":"","loc":"sourcefile/m_overload.f90.html"},{"title":"demo_M_overload.f90 – M_overload","text":"Contents Programs demo_M_overload Source Code demo_M_overload.f90 Source Code program demo_M_overload use , intrinsic :: iso_fortran_env , only : & & integer_kinds , int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : & & real32 , real64 , real128 ! allow strings to be converted to integers use M_overload , only : int ! allow strings to be converted to floating point use M_overload , only : real , dble ! use == like .eqv. use M_overload , only : operator ( == ) ! use /= like .neqv. use M_overload , only : operator ( /= ) use M_overload , only : operator ( // ) ! take a single argument use M_overload , only : sign ! allow strings of different length on merge use M_overload , only : merge implicit none character ( len = :), allocatable :: cmd character ( len =* ), parameter :: gen = '(*(\"[\",g0,\"]\":,\",\"))' write ( * , gen ) merge ( 'a' , 'bbbbb' , 1. eq . 1 ) write ( * , gen ) merge ( 'a' , 'bbbbb' , 1. eq . 2 ) write ( * , gen ) merge ([ 'a' , 'b' ],[ 'bbbbb' , 'ccccc' ], 1. eq . 2 ) if ( int ( '1234' ) . eq . 1234 ) & & write ( * , * ) 'int(\"STRING\") works ' if ( abs ( real ( '1234.56789' ) - 123 4.56789 ). lt . 2 * epsilon ( 0.0 )) & & write ( * , * ) 'real(\"STRING\") works ' if ( abs ( dble ( '1234.5678901234567' ) - 123 4.5678901234567d0 ). lt . epsilon ( 0.0d0 )) & & write ( * , * ) 'dble(\"STRING\") works ' if (. true . == . true . ) & & write ( * , * ) '== works like .eqv. for LOGICAL values' if (. true . /= . false . ) & & write ( * , * ) '/= works like .neqv. for LOGICAL values' write ( * , * ) ' The value is ' // 10 // ' which is less than ' // 2 0.2 write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int8 ). eq . 1 & & . and . sign ( - 10_int8 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int16 ). eq . 1 & & . and . sign ( - 10_int16 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int32 ). eq . 1 & & . and . sign ( - 10_int32 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int64 ). eq . 1 & & . and . sign ( - 10_int64 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 1 0.0_real32 ). eq . 1.0 & & . and . sign ( - 1 0.0_real32 ). eq . - 1.0 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 1 0.0_real64 ). eq . 1.0 & & . and . sign ( - 1 0.0_real64 ). eq . - 1.0 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 1 0.0_real128 ). eq . 1.0 & & . and . sign ( - 1 0.0_real128 ). eq . - 1.0 ) contains end program demo_M_overload","tags":"","loc":"sourcefile/demo_m_overload.f90.html"},{"title":"test_suite_M_overload.f90 – M_overload","text":"Contents Programs runtest Modules M_test_suite_M_overload Source Code test_suite_M_overload.f90 Source Code module M_test_suite_M_overload use , intrinsic :: iso_fortran_env , only : integer_kinds , int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level use M_overload private public test_suite_m_overload contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== ! BUG REPORTS: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=103782 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine test_suite_M_overload () use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_level use M_verify , only : almost !use M_compare_float_numbers, only : operator(.EqualTo.) implicit none character ( len = :), allocatable :: cmd !! setup unit_check_level = 5 if ( command_argument_count (). eq . 0 ) then call test_boolean_equal () call test_boolean_notequal () call test_dble_s2v () call test_dbles_s2v () call test_int_s2v () call test_ints_s2v () call test_real_s2v () call test_reals_s2v () call test_sign () !$!      call get_command(cmd,realloc=.true.) !$!      cmd=cmd//' -x -y \"hello there\" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' !$!      call execute_command_line(cmd) !$!   else !$!      call test_get_command() !$!      call test_get_command_argument() endif !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sign () !use M_overload,              only : operator(==) call unit_check_start ( 'sign' , ' & & -description \"overload SIGN to take a single argument\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'sign' , sign ( 10_int8 ). eq . 1. and . sign ( - 10_int8 ). eq . - 1 , 'sign(+-10_int8)' , sign ( 10_int8 ), sign ( - 10_int8 )) call unit_check ( 'sign' , sign ( 10_int16 ). eq . 1. and . sign ( - 10_int16 ). eq . - 1 , 'sign(+-10_int16)' , sign ( 10_int16 ), sign ( - 10_int16 )) call unit_check ( 'sign' , sign ( 10_int32 ). eq . 1. and . sign ( - 10_int32 ). eq . - 1 , 'sign(+-10_int32)' , sign ( 10_int32 ), sign ( - 10_int32 )) call unit_check ( 'sign' , sign ( 10_int64 ). eq . 1. and . sign ( - 10_int64 ). eq . - 1 , 'sign(+-10_int64)' , sign ( 10_int64 ), sign ( - 10_int64 )) call unit_check ( 'sign' , sign ( 1 0.0_real32 ). eq . 1. and . sign ( - 1 0.0_real32 ). eq . - 1 ,& & 'sign(+-10_real32)' , sign ( 1 0.0_real32 ), sign ( - 1 0.0_real32 )) call unit_check ( 'sign' , sign ( 1 0.0_real64 ). eq . 1. and . sign ( - 1 0.0_real64 ). eq . - 1 ,& & 'sign(+-10_real64)' , sign ( 1 0.0_real64 ), sign ( - 1 0.0_real64 )) call unit_check ( 'sign' , sign ( 1 0.0_real128 ). eq . 1. and . sign ( - 1 0.0_real128 ). eq . - 1 ,& & 'sign(+-10_real128)' , sign ( 1 0.0_real128 ), sign ( - 1 0.0_real128 )) call unit_check_done ( 'sign' , msg = '' ) end subroutine test_sign !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_boolean_equal () !use M_overload,              only : operator(==) call unit_check_start ( 'boolean_equal' , ' & & -description \"overload == to take LOGICAL arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'boolean_equal' ,. true . == . true . , '== works like .eqv. for LOGICAL values' ) call unit_check_done ( 'boolean_equal' , msg = '' ) end subroutine test_boolean_equal !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_boolean_notequal () !use M_overload,              only : operator(/=) call unit_check_start ( 'boolean_notequal' , ' & & -description \"overload /= to take LOGICAL arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'boolean_notequal' , (. true . /= . false . ), '/= works like .neqv. for LOGICAL values' ) call unit_check_done ( 'boolean_notequal' , msg = '' ) end subroutine test_boolean_notequal !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dble_s2v () !use M_overload,              only : int, real, dble call unit_check_start ( 'dble_s2v' , ' & & -description \"overload dble() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) if ( dble ( '0.3570726221234567' ). eq . 0.3570726221234567d0 ) then call unit_check_good ( 'dble_s2v' ) ! string passed to dble !   elseif(dble('0.3570726221234567') .EqualTo. 0.3570726221234567d0 )then elseif ( abs ( dble ( '0.3570726221234567' ) - 0.3570726221234567d0 ). lt . 2 * epsilon ( 0.0d0 )) then call unit_check_good ( 'dble_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'dble_s2v' ) ! returned value not equal to expected value endif end subroutine test_dble_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dbles_s2v () doubleprecision , allocatable :: vals (:) call unit_check_start ( 'dbles_s2v' , ' & & -description \"overload dble() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) vals = dble ([ '10.0d0' , '20.0d0' ]) vals = vals - [ 1 0.0d0 , 2 0.0d0 ] if ( all ( vals . eq . 0.0d0 )) then call unit_check_good ( 'dbles_s2v' ) ! string passed to dble elseif ( all ( vals . lt . 2 * epsilon ( 0.0d0 ))) then call unit_check_good ( 'dbles_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'dbles_s2v' ) ! returned value not equal to expected value endif !!   ENCOUNTERS GFORTRAN 10.3.0 BUG !!   if(all(abs(dble(['10.0d0','20.0d0']).eq.[10.0d0,20.0d0])))then !!      call unit_check_good('dbles_s2v')                                             ! string passed to dble !!!   elseif(all(dble(['10.0d0','20.0d0']) .EqualTo. [10.0d0,20.0d0]))then !!   elseif(all(abs(dble(['10.0d0','20.0d0']) - [10.0d0,20.0d0]).lt.2*epsilon(0.0d0)))then !!      call unit_check_good('dbles_s2v')                                             ! string passed to real but not exactly !!   else !!      call unit_check_bad('dbles_s2v')                                              ! returned value not equal to expected value !!   endif end subroutine test_dbles_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_int_s2v () call unit_check_start ( 'int_s2v' , ' & & -description \"overload INT() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'int_s2v' , int ( '1234' ). eq . 1234 , 'string passed to int' ) call unit_check_done ( 'int_s2v' , msg = '' ) end subroutine test_int_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ints_s2v () integer , allocatable :: ibug (:) call unit_check_start ( 'ints_s2v' , ' & & -description \"overload INT() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) !!if(all(int(['100','200']).eq. [100,200]))then ibug = int ([ '100' , '200' ]) if ( all ( ibug . eq . [ 100 , 200 ])) then call unit_check_good ( 'ints_s2v' ) ! string passed to int else call unit_check_bad ( 'ints_s2v' ) ! returned value not equal to expected value endif end subroutine test_ints_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_real_s2v () call unit_check_start ( 'real_s2v' , '& & -description \"overload REAL() to take string arguments\" & & -section 3                    & & -library libGPF               & & -filename `pwd`/M_overload.FF & & -documentation y              & &  -prep         y              & &  -ccall        n              & &  -archive      GPF.a          & & ' ) if ( REAL ( '0.357072622' ). eq . 0.357072622 ) then call unit_check_good ( 'real_s2v' ) elseif ( almost ( real ( '0.357072622' ), 0.357072622 , 7.0 ) ) then call unit_check_good ( 'real_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'real_s2v' ) ! returned value not equal to expected value endif end subroutine test_real_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_reals_s2v () real , allocatable :: rbug (:) call unit_check_start ( 'reals_s2v' , '& & -description \"overload REAL() to take string arguments\" & & -section 3                    & & -library libGPF               & & -filename `pwd`/M_overload.FF & & -documentation y              & &  -prep         y              & &  -ccall        n              & &  -archive      GPF.a          & & ' ) rbug = real ([ '0.357072622' , '200.0      ' ]) if ( all ( rbug . eq . [ 0.357072622 , 20 0.0 ])) then call unit_check_good ( 'reals_s2v' ) ! string passed to int !   elseif(all(real(['0.357072622','200.0      ']) .EqualTo. [0.357072622,200.0]))then elseif ( all ( abs ( real ([ '0.357072622' , '200.0      ' ]) - [ 0.357072622 , 20 0.0 ]). lt . 2 * epsilon ( 0.0d0 ))) then call unit_check_good ( 'reals_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'reals_s2v' ) ! returned value not equal to expected value endif end subroutine test_reals_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !$!subroutine test_get_command() !$!   call unit_check_start('get_command','& !$!         & -description \"overload GET_COMMAND() to take allocatable string\" & !$!         & -section 3                    & !$!         & -library libGPF               & !$!         & -filename `pwd`/M_overload.FF & !$!         & -documentation y              & !$!         &  -prep         y              & !$!         &  -ccall        n              & !$!         &  -archive      GPF.a          & !$!         & ') !$!   call unit_check_done('get_command',msg='') !$!end subroutine test_get_command !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !$!subroutine test_get_command_argument() !$!integer                      :: istat, ilen, i !$!character(len=:),allocatable :: argument, arguments !$!character(len=10)            :: regular !$!integer,allocatable          :: istats(:), ilens(:) !$!! assuming called with cmd//' -x -y \"hello there\" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' !$!   call unit_check_start('get_command_argument','& !$!    & -description \"overload GET_command_argument() to take allocatable string\" & !$!    & -section 3                    & !$!    & -library libGPF               & !$!    & -filename `pwd`/M_overload.FF & !$!    & -documentation y              & !$!    &  -prep         y              & !$!    &  -ccall        n              & !$!    &  -archive      GPF.a          & !$!    & ') !$! !$!   ! unallocated allocatable variable and realloc=.true. !$!   allocate(integer :: istats(0),ilens(0)) !$!   arguments='' !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, argument, length=ilen, status=istat, realloc=.true.) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//argument//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.0),'check if all status returns are zero') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x -y hello there xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') !$! !$!   ! allocated allocatable variable and realloc=.true. !$!   if(allocated(istats))deallocate(istats) !$!   if(allocated(ilens))deallocate(ilens) !$!   if(allocated(argument))deallocate(argument) !$!   allocate(integer :: istats(0),ilens(0)) !$!   argument='12345678901234' !$!   arguments='' !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, argument, length=ilen, status=istat, realloc=.true.) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//argument//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.0),'check if all status returns are zero') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x -y hello there xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') !$! !$!   ! allocatable variable already allocated and no realloc=.true. !$!   deallocate(istats,ilens,argument) !$!   allocate(integer :: istats(0),ilens(0)) !$!   arguments='' !$!   allocate(character(len=10) :: argument) !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, argument, length=ilen, status=istat) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//argument//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.[0,0,-1,-1]),'check if get truncations as expected') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x         -y         hello ther xxxxxxxxxx') !$! !$!   ! regular !$!   deallocate(istats,ilens) !$!   allocate(integer :: istats(0),ilens(0)) !$!   arguments='' !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, regular, length=ilen, status=istat) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//regular//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.[0,0,-1,-1]),'check if get truncations as expected') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x         -y         hello ther xxxxxxxxxx') !$! !$!   call unit_check_done('get_command_argument',msg='') !$!end subroutine test_get_command_argument !=================================================================================================================================== end subroutine test_suite_M_overload end module M_test_suite_M_overload program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_test_suite_M_overload implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_overload () call unit_check_stop () end program runtest","tags":"","loc":"sourcefile/test_suite_m_overload.f90.html"},{"title":"boolean_equal – M_overload","text":"public function boolean_equal(logical_val1, logical_val2) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_val1 logical, intent(in) :: logical_val2 Return Value logical Contents Source Code boolean_equal Source Code logical function boolean_equal ( logical_val1 , logical_val2 ) logical , intent ( in ) :: logical_val1 logical , intent ( in ) :: logical_val2 if ( logical_val1 . eqv . logical_val2 ) then boolean_equal = . true . else boolean_equal = . false . endif end function boolean_equal","tags":"","loc":"proc/boolean_equal.html"},{"title":"boolean_notequal – M_overload","text":"public function boolean_notequal(logical_val1, logical_val2) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_val1 logical, intent(in) :: logical_val2 Return Value logical Contents Source Code boolean_notequal Source Code logical function boolean_notequal ( logical_val1 , logical_val2 ) logical , intent ( in ) :: logical_val1 logical , intent ( in ) :: logical_val2 if ( logical_val1 . eqv . logical_val2 ) then boolean_notequal = . false . else boolean_notequal = . true . endif end function boolean_notequal","tags":"","loc":"proc/boolean_notequal.html"},{"title":"adjustl – M_overload","text":"public interface adjustl Contents Module Procedures adjustl_atleast Module Procedures private function adjustl_atleast(line, length) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length Return Value character(len=max(length,len(trim(line))))","tags":"","loc":"interface/adjustl.html"},{"title":"adjustr – M_overload","text":"public interface adjustr Contents Module Procedures adjustr_atleast Module Procedures private function adjustr_atleast(line, length) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length Return Value character(len=max(length,len(trim(line))))","tags":"","loc":"interface/adjustr.html"},{"title":"dble – M_overload","text":"public interface dble Contents Module Procedures dbles_s2v Module Procedures private function dbles_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value doubleprecision,\n  allocatable, (:)","tags":"","loc":"interface/dble.html"},{"title":"int – M_overload","text":"public interface int Contents Module Procedures ints_s2v Module Procedures private function ints_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value integer,\n  allocatable, (:)","tags":"","loc":"interface/int.html"},{"title":"merge – M_overload","text":"public interface merge Contents Module Procedures strmerge Module Procedures private elemental function strmerge(str1, str2, expr) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 logical, intent(in) :: expr Return Value character(len=max(len(str1),len(str2)))","tags":"","loc":"interface/merge.html"},{"title":"real – M_overload","text":"public interface real Contents Module Procedures reals_s2v Module Procedures private function reals_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value real,\n  allocatable, (:)","tags":"","loc":"interface/real.html"},{"title":"sign – M_overload","text":"public interface sign Contents Module Procedures sign_int8 Module Procedures private elemental function sign_int8(value) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: value Return Value integer(kind=int8)","tags":"","loc":"interface/sign.html"},{"title":"test_suite_M_overload – M_overload","text":"public subroutine test_suite_M_overload() Uses M_verify M_verify M_verify teardown Arguments None Contents Variables cmd Subroutines test_boolean_equal test_boolean_notequal test_dble_s2v test_dbles_s2v test_int_s2v test_ints_s2v test_real_s2v test_reals_s2v test_sign Source Code test_suite_M_overload Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cmd setup Subroutines subroutine test_boolean_equal() Arguments None subroutine test_boolean_notequal() Arguments None subroutine test_dble_s2v() Arguments None subroutine test_dbles_s2v() ENCOUNTERS GFORTRAN 10.3.0 BUG\n   if(all(abs(dble([‘10.0d0’,‘20.0d0’]).eq.[10.0d0,20.0d0])))then\n      call unit_check_good(‘dbles_s2v’)                                             ! string passed to dble\n!   elseif(all(dble([‘10.0d0’,‘20.0d0’]) .EqualTo. [10.0d0,20.0d0]))then\n   elseif(all(abs(dble([‘10.0d0’,‘20.0d0’]) - [10.0d0,20.0d0]).lt.2*epsilon(0.0d0)))then\n      call unit_check_good(‘dbles_s2v’)                                             ! string passed to real but not exactly\n   else\n      call unit_check_bad(‘dbles_s2v’)                                              ! returned value not equal to expected value\n   endif Arguments None subroutine test_int_s2v() Arguments None subroutine test_ints_s2v() if(all(int([‘100’,‘200’]).eq. [100,200]))then Arguments None subroutine test_real_s2v() Arguments None subroutine test_reals_s2v() Arguments None subroutine test_sign() Arguments None Source Code subroutine test_suite_M_overload () use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_level use M_verify , only : almost !use M_compare_float_numbers, only : operator(.EqualTo.) implicit none character ( len = :), allocatable :: cmd !! setup unit_check_level = 5 if ( command_argument_count (). eq . 0 ) then call test_boolean_equal () call test_boolean_notequal () call test_dble_s2v () call test_dbles_s2v () call test_int_s2v () call test_ints_s2v () call test_real_s2v () call test_reals_s2v () call test_sign () !$!      call get_command(cmd,realloc=.true.) !$!      cmd=cmd//' -x -y \"hello there\" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' !$!      call execute_command_line(cmd) !$!   else !$!      call test_get_command() !$!      call test_get_command_argument() endif !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sign () !use M_overload,              only : operator(==) call unit_check_start ( 'sign' , ' & & -description \"overload SIGN to take a single argument\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'sign' , sign ( 10_int8 ). eq . 1. and . sign ( - 10_int8 ). eq . - 1 , 'sign(+-10_int8)' , sign ( 10_int8 ), sign ( - 10_int8 )) call unit_check ( 'sign' , sign ( 10_int16 ). eq . 1. and . sign ( - 10_int16 ). eq . - 1 , 'sign(+-10_int16)' , sign ( 10_int16 ), sign ( - 10_int16 )) call unit_check ( 'sign' , sign ( 10_int32 ). eq . 1. and . sign ( - 10_int32 ). eq . - 1 , 'sign(+-10_int32)' , sign ( 10_int32 ), sign ( - 10_int32 )) call unit_check ( 'sign' , sign ( 10_int64 ). eq . 1. and . sign ( - 10_int64 ). eq . - 1 , 'sign(+-10_int64)' , sign ( 10_int64 ), sign ( - 10_int64 )) call unit_check ( 'sign' , sign ( 1 0.0_real32 ). eq . 1. and . sign ( - 1 0.0_real32 ). eq . - 1 ,& & 'sign(+-10_real32)' , sign ( 1 0.0_real32 ), sign ( - 1 0.0_real32 )) call unit_check ( 'sign' , sign ( 1 0.0_real64 ). eq . 1. and . sign ( - 1 0.0_real64 ). eq . - 1 ,& & 'sign(+-10_real64)' , sign ( 1 0.0_real64 ), sign ( - 1 0.0_real64 )) call unit_check ( 'sign' , sign ( 1 0.0_real128 ). eq . 1. and . sign ( - 1 0.0_real128 ). eq . - 1 ,& & 'sign(+-10_real128)' , sign ( 1 0.0_real128 ), sign ( - 1 0.0_real128 )) call unit_check_done ( 'sign' , msg = '' ) end subroutine test_sign !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_boolean_equal () !use M_overload,              only : operator(==) call unit_check_start ( 'boolean_equal' , ' & & -description \"overload == to take LOGICAL arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'boolean_equal' ,. true . == . true . , '== works like .eqv. for LOGICAL values' ) call unit_check_done ( 'boolean_equal' , msg = '' ) end subroutine test_boolean_equal !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_boolean_notequal () !use M_overload,              only : operator(/=) call unit_check_start ( 'boolean_notequal' , ' & & -description \"overload /= to take LOGICAL arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'boolean_notequal' , (. true . /= . false . ), '/= works like .neqv. for LOGICAL values' ) call unit_check_done ( 'boolean_notequal' , msg = '' ) end subroutine test_boolean_notequal !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dble_s2v () !use M_overload,              only : int, real, dble call unit_check_start ( 'dble_s2v' , ' & & -description \"overload dble() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) if ( dble ( '0.3570726221234567' ). eq . 0.3570726221234567d0 ) then call unit_check_good ( 'dble_s2v' ) ! string passed to dble !   elseif(dble('0.3570726221234567') .EqualTo. 0.3570726221234567d0 )then elseif ( abs ( dble ( '0.3570726221234567' ) - 0.3570726221234567d0 ). lt . 2 * epsilon ( 0.0d0 )) then call unit_check_good ( 'dble_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'dble_s2v' ) ! returned value not equal to expected value endif end subroutine test_dble_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dbles_s2v () doubleprecision , allocatable :: vals (:) call unit_check_start ( 'dbles_s2v' , ' & & -description \"overload dble() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) vals = dble ([ '10.0d0' , '20.0d0' ]) vals = vals - [ 1 0.0d0 , 2 0.0d0 ] if ( all ( vals . eq . 0.0d0 )) then call unit_check_good ( 'dbles_s2v' ) ! string passed to dble elseif ( all ( vals . lt . 2 * epsilon ( 0.0d0 ))) then call unit_check_good ( 'dbles_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'dbles_s2v' ) ! returned value not equal to expected value endif !!   ENCOUNTERS GFORTRAN 10.3.0 BUG !!   if(all(abs(dble(['10.0d0','20.0d0']).eq.[10.0d0,20.0d0])))then !!      call unit_check_good('dbles_s2v')                                             ! string passed to dble !!!   elseif(all(dble(['10.0d0','20.0d0']) .EqualTo. [10.0d0,20.0d0]))then !!   elseif(all(abs(dble(['10.0d0','20.0d0']) - [10.0d0,20.0d0]).lt.2*epsilon(0.0d0)))then !!      call unit_check_good('dbles_s2v')                                             ! string passed to real but not exactly !!   else !!      call unit_check_bad('dbles_s2v')                                              ! returned value not equal to expected value !!   endif end subroutine test_dbles_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_int_s2v () call unit_check_start ( 'int_s2v' , ' & & -description \"overload INT() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) call unit_check ( 'int_s2v' , int ( '1234' ). eq . 1234 , 'string passed to int' ) call unit_check_done ( 'int_s2v' , msg = '' ) end subroutine test_int_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ints_s2v () integer , allocatable :: ibug (:) call unit_check_start ( 'ints_s2v' , ' & & -description \"overload INT() to take string arguments\" & & -section 3  & & -library libGPF  & & -filename `pwd`/M_overload.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) !!if(all(int(['100','200']).eq. [100,200]))then ibug = int ([ '100' , '200' ]) if ( all ( ibug . eq . [ 100 , 200 ])) then call unit_check_good ( 'ints_s2v' ) ! string passed to int else call unit_check_bad ( 'ints_s2v' ) ! returned value not equal to expected value endif end subroutine test_ints_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_real_s2v () call unit_check_start ( 'real_s2v' , '& & -description \"overload REAL() to take string arguments\" & & -section 3                    & & -library libGPF               & & -filename `pwd`/M_overload.FF & & -documentation y              & &  -prep         y              & &  -ccall        n              & &  -archive      GPF.a          & & ' ) if ( REAL ( '0.357072622' ). eq . 0.357072622 ) then call unit_check_good ( 'real_s2v' ) elseif ( almost ( real ( '0.357072622' ), 0.357072622 , 7.0 ) ) then call unit_check_good ( 'real_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'real_s2v' ) ! returned value not equal to expected value endif end subroutine test_real_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_reals_s2v () real , allocatable :: rbug (:) call unit_check_start ( 'reals_s2v' , '& & -description \"overload REAL() to take string arguments\" & & -section 3                    & & -library libGPF               & & -filename `pwd`/M_overload.FF & & -documentation y              & &  -prep         y              & &  -ccall        n              & &  -archive      GPF.a          & & ' ) rbug = real ([ '0.357072622' , '200.0      ' ]) if ( all ( rbug . eq . [ 0.357072622 , 20 0.0 ])) then call unit_check_good ( 'reals_s2v' ) ! string passed to int !   elseif(all(real(['0.357072622','200.0      ']) .EqualTo. [0.357072622,200.0]))then elseif ( all ( abs ( real ([ '0.357072622' , '200.0      ' ]) - [ 0.357072622 , 20 0.0 ]). lt . 2 * epsilon ( 0.0d0 ))) then call unit_check_good ( 'reals_s2v' ) ! string passed to real but not exactly else call unit_check_bad ( 'reals_s2v' ) ! returned value not equal to expected value endif end subroutine test_reals_s2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !$!subroutine test_get_command() !$!   call unit_check_start('get_command','& !$!         & -description \"overload GET_COMMAND() to take allocatable string\" & !$!         & -section 3                    & !$!         & -library libGPF               & !$!         & -filename `pwd`/M_overload.FF & !$!         & -documentation y              & !$!         &  -prep         y              & !$!         &  -ccall        n              & !$!         &  -archive      GPF.a          & !$!         & ') !$!   call unit_check_done('get_command',msg='') !$!end subroutine test_get_command !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !$!subroutine test_get_command_argument() !$!integer                      :: istat, ilen, i !$!character(len=:),allocatable :: argument, arguments !$!character(len=10)            :: regular !$!integer,allocatable          :: istats(:), ilens(:) !$!! assuming called with cmd//' -x -y \"hello there\" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' !$!   call unit_check_start('get_command_argument','& !$!    & -description \"overload GET_command_argument() to take allocatable string\" & !$!    & -section 3                    & !$!    & -library libGPF               & !$!    & -filename `pwd`/M_overload.FF & !$!    & -documentation y              & !$!    &  -prep         y              & !$!    &  -ccall        n              & !$!    &  -archive      GPF.a          & !$!    & ') !$! !$!   ! unallocated allocatable variable and realloc=.true. !$!   allocate(integer :: istats(0),ilens(0)) !$!   arguments='' !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, argument, length=ilen, status=istat, realloc=.true.) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//argument//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.0),'check if all status returns are zero') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x -y hello there xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') !$! !$!   ! allocated allocatable variable and realloc=.true. !$!   if(allocated(istats))deallocate(istats) !$!   if(allocated(ilens))deallocate(ilens) !$!   if(allocated(argument))deallocate(argument) !$!   allocate(integer :: istats(0),ilens(0)) !$!   argument='12345678901234' !$!   arguments='' !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, argument, length=ilen, status=istat, realloc=.true.) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//argument//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.0),'check if all status returns are zero') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x -y hello there xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') !$! !$!   ! allocatable variable already allocated and no realloc=.true. !$!   deallocate(istats,ilens,argument) !$!   allocate(integer :: istats(0),ilens(0)) !$!   arguments='' !$!   allocate(character(len=10) :: argument) !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, argument, length=ilen, status=istat) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//argument//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.[0,0,-1,-1]),'check if get truncations as expected') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x         -y         hello ther xxxxxxxxxx') !$! !$!   ! regular !$!   deallocate(istats,ilens) !$!   allocate(integer :: istats(0),ilens(0)) !$!   arguments='' !$!   do i=1, command_argument_count() !$!      call get_command_argument(i, regular, length=ilen, status=istat) !$!      istats=[istats,istat] !$!      ilens=[ilens,ilen] !$!      arguments=arguments//regular//' ' !$!   enddo !$!   write(*,*)'ISTATS=',istats !$!   write(*,*)'ILENS=',ilens !$!   write(*,*)'ARGUMENTS=',arguments !$!   call unit_check('get_command_argument',all(istats.eq.[0,0,-1,-1]),'check if get truncations as expected') !$!   call unit_check('get_command_argument',all(ilens.eq.[2,2,11,36]),'check lengths') !$!   call unit_check('get_command_argument',arguments.eq.'-x         -y         hello ther xxxxxxxxxx') !$! !$!   call unit_check_done('get_command_argument',msg='') !$!end subroutine test_get_command_argument !=================================================================================================================================== end subroutine test_suite_M_overload","tags":"","loc":"proc/test_suite_m_overload.html"},{"title":"m_overload – M_overload","text":"NAME M_overload ( 3 fm ) - [ M_overload ] overloads of standard operators and intrinsic procedures ( LICENSE : PD ) SYNOPSIS overloads on LOGICAL values ! use == like . eqv . ; ie . logical == logical use M_overload , only : operator ( == ) ! use /= like . neqv . ; ie . logical /= logical use M_overload , only : operator ( /= ) overloads on INTRINSICS to take strings, logicals, and metamorphic numeric intrinsic values use M_overload, only : int, real, dble\n   ! int(‘string’)   int(logical)   int(class( ))\n   ! real(‘string’)  real(logical)  real(class( ))\n   ! dble(‘string’)  dble(logical)  dble(class(*)) overloads on operators use M_overload, only : operator(==)\n   ! INTRINSIC // INTRINSIC // INTRINSIC … ! When sign(3f) is given a single value, call sign(1,value); ie.  sign(value)\n   use M_overload, only : sign Allow strings of different length in MERGE use M_overload, only : merge\n   ! str=merge(‘one’,’three’,i.eq.10) OTHER OPERATORS intrinsic_value . fmt . '' convert an intrinsic value to a CHARACTER variable DESCRIPTION Operator and function overloads have a wide range of applications\n   from allowing existing Fortran routines to be used with almost no\n   source-code changes to produce versions using arbitrary precision\n   or cumulative error bounds on floating-point calculations to adding\n   intuitive syntax for standard Fortran operations. OVERLOADS //       overloads // to concatenate any two intrinsic types into a string ==,/=    Allow the syntax “L1 == L2”  and “L1 /= L2” where L1 and L2 are\n            type LOGICAL as an alternative to the standard expressions\n            “L1 .EQV. L2” and “L1 .NEQV. L2”. It should be pointed out that L1 == L2 !! should be L1 . eqv . L2 and L1 /= L2 !! should be L1 . neqv . L2 should NOT work by default ; but often do (probably because the compiler silently converts LOGICAL to INTEGER when a LOGICAL appears where a numeric value is required ) . If your compiler supports this non - standard ( but intuitive - looking ) syntax you can use this module to allow the syntax in a portable manner with a standard method . int () , real () , dble () allow strings to be converted to numeric values using the standard intrinsic names sign ( value ) call sign ( 1 , value ) str = merge ( ' little ' , ' big ' , a . eq . 10 ) allows for strings of different lengths EXAMPLES Sample usage: program demo_M_overload use , intrinsic :: iso_fortran_env , only : & & integer_kinds , int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : & & real32 , real64 , real128 ! allow strings to be converted to integers use M_overload , only : int ! allow strings to be converted to floating point use M_overload , only : real , dble ! use == like . eqv . use M_overload , only : operator ( == ) ! use /= like . neqv . use M_overload , only : operator ( /= ) use M_overload , only : operator ( // ) ! take a single argument use M_overload , only : sign ! allow strings of different length on merge use M_overload , only : merge implicit none character ( len = :), allocatable :: cmd character ( len =* ), parameter :: gen = '(*(\"[\",g0,\"]\":,\",\"))' write ( * , gen ) merge ( 'a' , 'bbbbb' , 1. eq . 1 ) write ( * , gen ) merge ( 'a' , 'bbbbb' , 1. eq . 2 ) write ( * , gen ) merge ([ 'a' , 'b' ],[ 'bbbbb' , 'ccccc' ], 1. eq . 2 ) if ( int ( '1234' ) . eq . 1234 ) & & write ( * , * ) 'int(\"STRING\") works ' if ( abs ( real ( '1234.56789' ) - 1234.56789 ) . lt . 2 * epsilon ( 0.0 )) & & write ( * , * ) 'real(\"STRING\") works ' if ( abs ( dble ( '1234.5678901234567' ) - 1234.5678901234567 d0 ) . lt . epsilon ( 0.0 d0 )) & & write ( * , * ) 'dble(\"STRING\") works ' if ( . true . == . true . ) & & write ( * , * ) '== works like .eqv. for LOGICAL values' if ( . true . /= . false . ) & & write ( * , * ) '/= works like .neqv. for LOGICAL values' write ( * , * ) ' The value is ' // 10 // ' which is less than ' // 20.2 write ( * , * ) merge ( 'sign works' , 'sign fails' , & & sign ( 10 _int8 ) . eq . 1 & & . and . sign ( - 10 _int8 ) . eq .- 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' , & & sign ( 10 _int16 ) . eq . 1 & & . and . sign ( - 10 _int16 ) . eq .- 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' , & & sign ( 10 _int32 ) . eq . 1 & & . and . sign ( - 10 _int32 ) . eq .- 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' , & & sign ( 10 _int64 ) . eq . 1 & & . and . sign ( - 10 _int64 ) . eq .- 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' , & & sign ( 10.0 _real32 ) . eq . 1.0 & & . and . sign ( - 10.0 _real32 ) . eq .- 1.0 ) write ( * , * ) merge ( 'sign works' , 'sign fails' , & & sign ( 10.0 _real64 ) . eq . 1.0 & & . and . sign ( - 10.0 _real64 ) . eq .- 1.0 ) write ( * , * ) merge ( 'sign works' , 'sign fails' , & & sign ( 10.0 _real128 ) . eq . 1.0 & & . and . sign ( - 10.0 _real128 ) . eq .- 1.0 ) contains end program demo_M_overload Results:\n     >  [a    ]\n     >  [bbbbb]\n     >  [bbbbb],[ccccc]\n     >  int(“STRING”) works\n     >  real(“STRING”) works\n     >  dble(“STRING”) works\n     >  == works like .eqv. for LOGICAL values\n     >  /= works like .neqv. for LOGICAL values\n     >          444         555\n     >    444.444000       555.554993\n     >    444.44400000000002        555.55500000000006\n     >    555.44399999999996        666.66600000000005        777.77700000000004\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     >  int(“STRING”) works\n     >  real(“STRING”) works\n     >  dble(“STRING”) works\n     >  == works like .eqv. for LOGICAL values\n     >  /= works like .neqv. for LOGICAL values\n     >          444         555\n     >    444.444000       555.554993\n     >    444.44400000000002        555.55500000000006\n     >    555.44399999999996        666.66600000000005        777.77700000000004\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     >  sign works\n     > 57 xx -x -y hello there xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n     > 0 0 [xx]\n     > 1 0 [-x]\n     > 2 0 [-y]\n     > 3 0 [hello there]\n     > 4 0 [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx]\n     > 0 0 [xx        ]\n     > 1 0 [-x        ]\n     > 2 0 [-y        ]\n     > 3 -1 [hello ther]\n     > 4 -1 [xxxxxxxxxx]\n     > 0 0 [xx                  ]\n     > 1 0 [-x                  ]\n     > 2 0 [-y                  ]\n     > 3 0 [hello there         ]\n     > 4 -1 [xxxxxxxxxxxxxxxxxxxx] AUTHOR John S. Urban LICENSE Public Domain interface int;     module procedure int_s2v;              end interface\ninterface real;    module procedure real_s2v;             end interface\ninterface dble;    module procedure dble_s2v;             end interface Uses iso_fortran_env Contents Interfaces adjustl adjustr dble int merge real sign Functions boolean_equal boolean_notequal Interfaces public interface adjustl private function adjustl_atleast(line, length) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length Return Value character(len=max(length,len(trim(line)))) public interface adjustr private function adjustr_atleast(line, length) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length Return Value character(len=max(length,len(trim(line)))) public interface dble private function dbles_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value doubleprecision,\n  allocatable, (:) public interface int private function ints_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value integer,\n  allocatable, (:) public interface merge private elemental function strmerge(str1, str2, expr) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 logical, intent(in) :: expr Return Value character(len=max(len(str1),len(str2))) public interface real private function reals_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value real,\n  allocatable, (:) public interface sign private elemental function sign_int8(value) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: value Return Value integer(kind=int8) Functions public function boolean_equal (logical_val1, logical_val2) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_val1 logical, intent(in) :: logical_val2 Return Value logical public function boolean_notequal (logical_val1, logical_val2) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_val1 logical, intent(in) :: logical_val2 Return Value logical","tags":"","loc":"module/m_overload.html"},{"title":"M_test_suite_M_overload – M_overload","text":"Uses iso_fortran_env iso_fortran_env M_msg M_verify m_overload Contents Subroutines test_suite_M_overload Subroutines public subroutine test_suite_M_overload () teardown Arguments None","tags":"","loc":"module/m_test_suite_m_overload.html"},{"title":"demo_M_overload – M_overload","text":"Uses iso_fortran_env iso_fortran_env m_overload m_overload m_overload m_overload m_overload m_overload m_overload Contents Variables cmd gen Source Code demo_M_overload Variables Type Attributes Name Initial character(len=:), allocatable :: cmd character(len=*), parameter :: gen = '(*(\"[\",g0,\"]\":,\",\"))' Source Code program demo_M_overload use , intrinsic :: iso_fortran_env , only : & & integer_kinds , int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : & & real32 , real64 , real128 ! allow strings to be converted to integers use M_overload , only : int ! allow strings to be converted to floating point use M_overload , only : real , dble ! use == like .eqv. use M_overload , only : operator ( == ) ! use /= like .neqv. use M_overload , only : operator ( /= ) use M_overload , only : operator ( // ) ! take a single argument use M_overload , only : sign ! allow strings of different length on merge use M_overload , only : merge implicit none character ( len = :), allocatable :: cmd character ( len =* ), parameter :: gen = '(*(\"[\",g0,\"]\":,\",\"))' write ( * , gen ) merge ( 'a' , 'bbbbb' , 1. eq . 1 ) write ( * , gen ) merge ( 'a' , 'bbbbb' , 1. eq . 2 ) write ( * , gen ) merge ([ 'a' , 'b' ],[ 'bbbbb' , 'ccccc' ], 1. eq . 2 ) if ( int ( '1234' ) . eq . 1234 ) & & write ( * , * ) 'int(\"STRING\") works ' if ( abs ( real ( '1234.56789' ) - 123 4.56789 ). lt . 2 * epsilon ( 0.0 )) & & write ( * , * ) 'real(\"STRING\") works ' if ( abs ( dble ( '1234.5678901234567' ) - 123 4.5678901234567d0 ). lt . epsilon ( 0.0d0 )) & & write ( * , * ) 'dble(\"STRING\") works ' if (. true . == . true . ) & & write ( * , * ) '== works like .eqv. for LOGICAL values' if (. true . /= . false . ) & & write ( * , * ) '/= works like .neqv. for LOGICAL values' write ( * , * ) ' The value is ' // 10 // ' which is less than ' // 2 0.2 write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int8 ). eq . 1 & & . and . sign ( - 10_int8 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int16 ). eq . 1 & & . and . sign ( - 10_int16 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int32 ). eq . 1 & & . and . sign ( - 10_int32 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 10_int64 ). eq . 1 & & . and . sign ( - 10_int64 ). eq . - 1 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 1 0.0_real32 ). eq . 1.0 & & . and . sign ( - 1 0.0_real32 ). eq . - 1.0 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 1 0.0_real64 ). eq . 1.0 & & . and . sign ( - 1 0.0_real64 ). eq . - 1.0 ) write ( * , * ) merge ( 'sign works' , 'sign fails' ,& & sign ( 1 0.0_real128 ). eq . 1.0 & & . and . sign ( - 1 0.0_real128 ). eq . - 1.0 ) contains end program demo_M_overload","tags":"","loc":"program/demo_m_overload.html"},{"title":"runtest – M_overload","text":"Uses M_msg M_verify M_test_suite_M_overload Contents Source Code runtest Source Code program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_test_suite_M_overload implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_overload () call unit_check_stop () end program runtest","tags":"","loc":"program/runtest.html"}]}