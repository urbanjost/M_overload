fmt (3m_overload)    - [M_overload] convert any intrinsic to a string using specified format (LICENSE:PD)
M_overload (3m_overload) - [M_overload::INTRO] overloads of standard operators and intrinsic procedures (LICENSE:PD)
oz (3m_overload)     - [M_overload::LOGICAL] returns One if expression is TRUE, else returns Zero. (LICENSE:PD)
to (3m_overload)     - [M_overload::LOGICAL] return array of adjacent integers over specified range, inclusive (LICENSE:PD)
zo (3m_overload)     - [M_overload::LOGICAL] returns Zero if expression is FALSE, else returns One. (LICENSE:PD)
M_overload(3m_overload) 			       M_overload(3m_overload)



NAME
  M_overload(3fm) - [M_overload::INTRO] overloads of standard operators and
  intrinsic procedures (LICENSE:PD)

SYNOPSIS
  overloads on operators

     use M_overload, only : operator(==), operator(/=)
     ! use == like .eqv.; ie. logical==logical
     ! use /= like .neqv.; ie. logical/=logical

     use M_overload, only : operator(//)
     ! convert intrinsics to strings and contatenate

  overloads on INTRINSICS to take strings, logicals, and metamorphic numeric
  intrinsic values

     use M_overload, only : int, real, dble
     ! int('string')   int(logical)   int(class(*))
     ! real('string')  real(logical)  real(class(*))
     ! dble('string')  dble(logical)  dble(class(*))

     use M_overload, only : sign
     ! When sign(3f) is given a single value, call sign(1,value); ie.  sign(value)
     use M_overload, only : merge
     ! Allow strings of different length in MERGE

  other operators

     .fmt.    ! convert an intrinsic value to a CHARACTER variable using format
     N.to.M   ! equivalent of [(integer :: i,i=N,M)], generates a range of
	      ! adjacent whole numbers

  Related functions

     ! logical functions that return integer values
     use M_overload, only : oz, zo, lt, le, eq, ne, gt, ge




DESCRIPTION
  Operator and function overloads have a wide range of applications from
  allowing existing Fortran routines to be used with almost no source-code
  changes to produce versions using arbitrary precision or cumulative error
  bounds on floating-point calculations to adding intuitive syntax for
  standard Fortran operations.

OVERLOADS
  //
    overloads // to concatenate any two intrinsic types into a string

  ==,/=
    Allow the syntax "L1 == L2"  and "L1 /= L2" where L1 and L2 are type
    LOGICAL as an alternative to the standard expressions "L1 .EQV. L2" and
    "L1 .NEQV. L2".

    It should be pointed out that

		  L1 == L2   !! should be L1 .eqv. L2

    and

		  L1 /= L2   !! should be L1 .neqv. L2

    should NOT work by default; but often do (probably because the compiler
    silently converts LOGICAL to INTEGER when a LOGICAL appears where a
    numeric value is required). If your compiler supports this non-standard
    (but intuitive-looking) syntax you can use this module to allow the syntax
    in a portable manner with a standard method.

  int(), real(), dble()
    allow strings to be converted to numeric values using the standard
    intrinsic names

    sign(value)
      call sign(1,value)

    str=merge('little','big',a.eq.10)
      allows for strings of different lengths

EXAMPLES
  Sample usage:

    program demo_M_overload

     use, intrinsic :: iso_fortran_env, only : &
	     & integer_kinds, int8, int16, int32, int64
     use, intrinsic :: iso_fortran_env, only : &
	     & real32, real64, real128

     ! allow strings to be converted to integers
     use M_overload, only : int
     ! allow strings to be converted to floating point
     use M_overload, only : real,dble
     ! use == like .eqv.
     use M_overload, only : operator(==)
     ! use /= like .neqv.
     use M_overload, only : operator(/=)
     use M_overload, only : operator(//)
     ! take a single argument
     use M_overload, only : sign
     ! allow strings of different length on merge
     use M_overload, only : merge
     ! convert logical expressions to integer
     use M_overload, only : oz, zo, lt, le, eq, ne, gt, ge
     implicit none
     character(len=:),allocatable :: cmd
     character(len=*), parameter :: gen='(*("[",g0,"]":,","))'

       ! merge() with different string lengths expanded to longest
       write(*,gen)merge('a','bbbbb',1.eq.1)
       write(*,gen)merge('a','bbbbb',1.eq.2)
       write(*,gen)merge(['a','b'],['bbbbb','ccccc'],1.eq.2)

       ! int() can take strings representing a number as input'
       if(int('1234')		    .eq.1234) &
	& write(*,*)'int("STRING") works '
       ! as can real() and dble()
       if(abs(real('1234.56789') - 1234.56789).lt.2*epsilon(0.0)) &
	& write(*,*)'real("STRING") works '
       if(abs(dble('1234.5678901234567')- 1234.5678901234567d0).lt.epsilon(0.0d0)) &
	& write(*,*)'dble("STRING") works '

       ! and logical values can be treated numerically
       write(*,*) merge('int works for .FALSE.','int fails for .FALSE.',int(.FALSE.).ne.0)
       write(*,*) merge('int works for .TRUE.','int fails for .TRUE.',int(.TRUE.).eq.0)
       write(*,*) sum(int([.true.,.false.,.true.]))

       ! and == and /= work for logical expressions
       if (.true. == .true. ) &
       & write(*,*)'== works like .eqv. for LOGICAL values'
       if (.true. /= .false. ) &
       & write(*,*)'/= works like .neqv. for LOGICAL values'

       ! // will allow any intrinsic type and convert it to a string
       write(*,*)' The value is '//10//' which is less than '//20.2
       block
       character(len=:),allocatable :: fmt
       integer :: i
	  i=24
	  ! build a format with a variable numeric value
	  fmt='("[",I'//i//',"]")'
	  write(*,fmt)20
       endblock

       ! logical values as numeric values
       write(*,*) sum([int(.false.),int(.false.)])
       write(*,*) int([.false.,.true.,.false.])
       write(*,*) sum(int([.false.,.true.,.false.]))


       ! and sign() assumes the second argument is 1
       write(*,*) merge('sign works','sign fails',&
	& sign(10_int8).eq.1 &
	& .and. sign(-10_int8).eq.-1 )

     contains

     end program demo_M_overload

  Results:

   > [a    ]
   > [bbbbb]
   > [bbbbb],[ccccc]
   >  int("STRING") works
   >  real("STRING") works
   >  dble("STRING") works
   >  int works for .FALSE.
   >  int works for .TRUE.
   >			 1
   >  == works like .eqv. for LOGICAL values
   >  /= works like .neqv. for LOGICAL values
   >   The value is 10 which is less than 20.2000008
   > [			    20]
   >			 2
   >			 1		      0 		   1
   >			 2
   >  sign works


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				 July 21, 2024	       M_overload(3m_overload)
to(3m_overload) 					       to(3m_overload)



NAME
  to(3f) - [M_overload::LOGICAL] return array of adjacent integers over
  specified range, inclusive (LICENSE:PD)

SYNOPSIS
  pure elemental integer function to(i,j)

      integer,intent(in) :: i
      integer,intent(in) :: j
      integer,allocatable :: to


DESCRIPTION
  A convenience for expressing [(integer :: i=N,M)]

OPTIONS
  I starting value

  J ending value

RETURNS
  An array of adjacent whole numbers from I to J

EXAMPLES
  Sample usage:

     program demo_to
     use M_overload, only: to, operator(.to.)
     implicit none
	print*,[11.to.16]
	print*,2.5 * [1.to.4]
	print*,2.5 * to(1,4)+10
     end program demo_to


AUTHOR
  John S. Urban, inspired by @beliavsky

LICENSE
  Public Domain



				 July 21, 2024		       to(3m_overload)
zo(3m_overload) 					       zo(3m_overload)



NAME
  zo(3f) - [M_overload::LOGICAL] returns Zero if expression is FALSE, else
  returns One.	(LICENSE:PD)

SYNOPSIS
  pure elemental integer function zo(expr)

      logical,intent(in) :: expr


DESCRIPTION
  Returns an integer given a logical expression.

OPTIONS
  expr
    A logical expression

RETURNS
  The result is a default INTEGER value of 0 if the expression is TRUE, and a
  1 otherwise.

EXAMPLES
  Sample usage:

     program demo_zo
     use M_overload, only: zo, zo, lt, le, eq, ne, gt, ge
     implicit none
     write (*, *) zo(10 < 20)
     if (sum(zo([1 > 2, 3 == 4, 10 < 5, 100 > 50])) > 2) then
	write (*, *) 'two or more are not true'
     endif
     end program demo_zo

  Results:

     >		 0
     >	two or more are not true


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				 July 21, 2024		       zo(3m_overload)
oz(3m_overload) 					       oz(3m_overload)



NAME
  oz(3f) - [M_overload::LOGICAL] returns One if expression is TRUE, else
  returns Zero.  (LICENSE:PD)

SYNOPSIS
  pure elemental integer function oz(expr)

      logical,intent(in) :: expr


DESCRIPTION
  Returns an integer given a logical expression.

OPTIONS
  expr
    A logical expression

RETURNS
  The result is a default INTEGER value of 1 if the expression is TRUE, and a
  0 otherwise.

EXAMPLES
  Sample usage:

     program demo_oz
     use M_overload, only: oz, zo, lt, le, eq, ne, gt, ge
     implicit none
	write (*, *) 'is 10 < 20 ?', oz(10 < 20)
	write (*, *) 'elemental', oz([2 > 1, 3 == 4, 10 < 5, 100 > 50])
	if (sum(oz([2 > 1, 3 == 4, 10 < 5, 100 > 50])) >= 2) then
	   write (*, *) 'two or more are true'
	endif
     end program demo_oz

  Results:

      > is 10 < 20 ? 1
      > elemental 1 0 0 1
      > two or more are true


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				 July 21, 2024		       oz(3m_overload)
fmt(3m_overload)					      fmt(3m_overload)



NAME
  fmt(3f) - [M_overload] convert any intrinsic to a string using specified
  format (LICENSE:PD)

SYNOPSIS
  function fmt(value,format) result(string)

      class(*),intent(in),optional :: value
      character(len=*),intent(in),optional :: format
      character(len=:),allocatable :: string

DESCRIPTION
  FMT(3f) converts any standard intrinsic value to a string using the
  specified format.

OPTIONS
  value
    value to print the value of. May be of type INTEGER, LOGICAL, REAL,
    DOUBLEPRECISION, COMPLEX, or CHARACTER.

  format
    format to use to print value. It is up to the user to use an appropriate
    format. The format does not require being surrounded by parenthesis. If
    not present a default is selected similar to what would be produced with
    free format, with trailing zeros removed.

RETURNS
  string
    A string value

EXAMPLES
  Sample program:

      program demo_fmt
      use :: M_overload, only : fmt
      use :: M_overload, only : operator(.fmt.)
      use :: M_overload, only : operator( // )
      implicit none
      character(len=:),allocatable :: output
      character(len=:), allocatable :: string

	 write(*,*)'result is ', fmt(10,"'[',i0,']'")

	 write(*,*)'result is ', fmt(10.0/3.0,"'[',g0.5,']'")

	 output=fmt(.true.,"'The final answer is [',g0,']'")
	 write(*,*)'result is ',output
	 ! operator
	 string=1234.fmt.'"[",i0,"]"'
	 write(*,*)string
	 ! tests
	 write(*,*)'the value is ',fmt(1234.5679,'f0.3'),' or there-abouts'

	 write(*,*)1234.0 .fmt. '"[",g0,"]"' ! .eq. '[1234]'

	 string=10//' is an integer and '//(11.00,22.00)//' is a complex'
	 write(*,*)string

      end program demo_fmt

  Results:

  > result is [10]

    > result is [3.3333]

    > result is The final answer is [T]

    > [1234]

    > the value is 1234.568 or there-abouts

    > [1234.00000]

    > 10 is an integer and <ERROR>End of file is a complex
      ================================================================================

AUTHOR
  John S. Urban

LICENSE
  Public Domain



				 July 21, 2024		      fmt(3m_overload)
